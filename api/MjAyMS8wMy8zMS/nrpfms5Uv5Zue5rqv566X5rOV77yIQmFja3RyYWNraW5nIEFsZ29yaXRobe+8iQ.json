{"title":"回溯算法（Backtracking Algorithm）","date":"2021-03-30T16:00:00.000Z","date_formatted":{"ll":"Mar 31, 2021","L":"03/31/2021","MM-DD":"03-31"},"link":"2021/03/31/算法/回溯算法（Backtracking Algorithm）","categories":["Algorithm"],"updated":"2021-04-24T11:21:25.441Z","content":"<h1 id=\"回溯算法（backtracking-algorithm）\">回溯算法（Backtracking Algorithm）<a title=\"#回溯算法（backtracking-algorithm）\" href=\"#回溯算法（backtracking-algorithm）\"></a></h1>\n<p>本文主要来源：</p>\n<ol>\n<li><a href=\"https://labuladong.gitbook.io/algo/\" target=\"_blank\">📋labuladong的算法小抄</a>-<a href=\"https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/hui-su-suan-fa-dfs-suan-fa/hui-su-suan-fa-xiang-jie-xiu-ding-ban\" target=\"_blank\">回溯算法接替套路框架</a></li>\n</ol>\n<p>回溯算法建立在DFS基础之上，<strong>不同的是在搜索的过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索</strong>。因此回溯算法和DFS的区别就是有无状态重叠。</p>\n<ul>\n<li>\n<p><strong>什么时候使用回溯算法</strong></p>\n<p>当问题需要“回头”，以此来查找出所有的解的时候，使用回溯算法。即满足结束条件或发现不是正确路径的时候（走不通），要撤销选择，回退到上一个状态，继续尝试，直到找到所有解为止。</p>\n</li>\n<li>\n<p><strong>回溯问题的类型</strong></p>\n<div class=\"φbt\"><div class=\"φbv\"><table><thead>\n<tr>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">题目</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">子集、组合</td>\n<td style=\"text-align:center\"><a href=\"https://leetcode-cn.com/problems/subsets/\" target=\"_blank\">子集</a>、<a href=\"https://leetcode-cn.com/problems/subsets-ii/\" target=\"_blank\">子集 II</a>、<a href=\"https://leetcode-cn.com/problems/combinations/\" target=\"_blank\">组合</a>、<a href=\"https://leetcode-cn.com/problems/combination-sum/\" target=\"_blank\">组合总和</a>、<a href=\"https://leetcode-cn.com/problems/combination-sum-ii/\" target=\"_blank\">组合总和 II</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">全排列</td>\n<td style=\"text-align:center\"><a href=\"https://leetcode-cn.com/problems/permutations/\" target=\"_blank\">全排列</a>、<a href=\"https://leetcode-cn.com/problems/permutations-ii/\" target=\"_blank\">全排列 II</a>、<a href=\"https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/\" target=\"_blank\">字符串的全排列</a>、<a href=\"https://leetcode-cn.com/problems/letter-case-permutation/\" target=\"_blank\">字母大小写全排列</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>搜索</strong></td>\n<td style=\"text-align:center\"><a href=\"https://leetcode-cn.com/problems/sudoku-solver/\" target=\"_blank\">解数独</a>、<a href=\"https://leetcode-cn.com/problems/word-search/\" target=\"_blank\">单词搜索</a>、<a href=\"https://leetcode-cn.com/problems/eight-queens-lcci/\" target=\"_blank\">N皇后</a>、<a href=\"https://leetcode-cn.com/problems/palindrome-partitioning/\" target=\"_blank\">分割回文串</a>、<a href=\"https://leetcode-cn.com/problems/binary-watch/\" target=\"_blank\">二进制手表</a></td>\n</tr>\n</tbody>\n</table></div></div><p>子集和组合是顺序无关的，而排列和元素顺序有关。e.g. [1,2]和[2,1]是同一个组合（子集），但[1,2]和[2,1]是两种不一样的排列。</p>\n</li>\n<li>\n<p><strong>需要思考的三个问题</strong></p>\n<ol>\n<li>路径：也就是已经做出的选择</li>\n<li>选择列表：也就是你当前可以做的选择</li>\n<li>结束条件：也就是到达决策树底层，无法再做选择的条件</li>\n</ol>\n</li>\n<li>\n<p><strong>回溯算法的框架</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = []</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span>(<span class=\"params\">路径, 选择列表</span>)：</span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"title\">if</span> 满足结束条件:</span></span><br><span class=\"line\">        result.add(路径)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> 选择 <span class=\"keyword\">in</span> 选择列表:</span><br><span class=\"line\">\t\t<span class=\"comment\"># 做选择</span></span><br><span class=\"line\">        将该选择从选择列表移除</span><br><span class=\"line\">      \t路径.add(选择)</span><br><span class=\"line\">        backtrack(路径, 选择列表)</span><br><span class=\"line\">        <span class=\"comment\">#撤销选择</span></span><br><span class=\"line\">        路径.remove(选择)</span><br><span class=\"line\">        将该选择再加入选择列表</span><br></pre></td></tr></table></figure>\n<p><strong>核心是<code>for</code>循环中的递归，在递归调用之前【做选择】，在递归调用之后【撤销选择】。</strong></p>\n</li>\n</ul>\n<p>e.g.<a href=\"https://leetcode-cn.com/problems/permutations/\" target=\"_blank\">全排列</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class=\"keyword\">int</span>[] nums)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//记录路径</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; track = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        backtrack(nums, track);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//路径：记录在track中</span></span><br><span class=\"line\">    <span class=\"comment\">//选择列表：nums中不存在于track的那些元素</span></span><br><span class=\"line\">    <span class=\"comment\">//结束条件：nums中的元素全都在track中出现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//触发结束条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(track.size()==nums.length)&#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> LinkedList(track));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//排除不合法的选择</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(track.contains(nums[i])) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//做选择</span></span><br><span class=\"line\">            track.add(nums[i]);</span><br><span class=\"line\">            <span class=\"comment\">//进入下一层决策树</span></span><br><span class=\"line\">            backtrack(nums, track);</span><br><span class=\"line\">            <span class=\"comment\">//取消选择</span></span><br><span class=\"line\">            track.removeLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>e.g. <a href=\"https://leetcode-cn.com/problems/subsets/\" target=\"_blank\">子集</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subsets = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = [];</span><br><span class=\"line\">    <span class=\"comment\">//记录走过的路程</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> track = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> backtrack = <span class=\"function\">(<span class=\"params\">nums, start, track</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        res.push(track.slice());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=start; i&lt;nums.length; i++)&#123;</span><br><span class=\"line\">            track.push(nums[i]);</span><br><span class=\"line\">            backtrack(nums, i+<span class=\"number\">1</span>, track);</span><br><span class=\"line\">            track.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    backtrack(nums, <span class=\"number\">0</span>, track);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>输入[1,2,3]，得到的结果是[[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/andrewyuanyuan/blog-image/img/006SqI8Pgy1gp3joaovnxj30s40iqwgw.jpg\" alt=\"pic1\" class=\"φbs\"></p>\n<h3 id=\"具体过程\">具体过程<a title=\"#具体过程\" href=\"#具体过程\"></a></h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/andrewyuanyuan/blog-image/img/IMG_2289(20210331-174230).PNG\" alt=\"pic2\" class=\"φbs\"></p>\n","prev":{"title":"二叉树（Binary Tree）","link":"2021/04/01/数据结构/二叉树（Binary Tree）"},"next":{"title":"note","link":"2021/03/30/JavaScript/Note"},"plink":"http://example.com/2021/03/31/算法/回溯算法（Backtracking Algorithm）/","toc":[{"id":"回溯算法（backtracking-algorithm）","title":"回溯算法（Backtracking Algorithm）","index":"1","children":[{"id":"具体过程","title":"具体过程","index":"1.1"}]}]}