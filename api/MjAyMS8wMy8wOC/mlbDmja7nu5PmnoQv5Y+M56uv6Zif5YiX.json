{"title":"双端队列","date":"2021-03-08T06:39:03.000Z","date_formatted":{"ll":"Mar 8, 2021","L":"03/08/2021","MM-DD":"03-08"},"link":"2021/03/08/数据结构/双端队列","categories":["Data Structure"],"updated":"2021-03-09T07:16:43.614Z","content":"<h1 id=\"双端队列\">双端队列<a title=\"#双端队列\" href=\"#双端队列\"></a></h1>\n<p>双端队列能让人们有效地在头部和尾部同时添加或删除元素，不支持在队列中间添加元素。</p>\n<p>Java中：</p>\n<p><code>Deque</code>的实现类是<code>LinkedList</code>， <code>ArrayDeque</code>，<code>LinkedBlockingDeque</code>，其中<code>LinkedList</code>是最常用的。</p>\n<p><code>Deque</code>是一个线性<code>Collection</code>，大多数<code>Deque</code>实现对于它们能包含的元素数量没有固定限制。但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。</p>\n<ul>\n<li>\n<p>双端队列</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deque deque = <span class=\"keyword\">new</span> LinkedList();</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>堆栈</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deque deque = <span class=\"keyword\">new</span> LinkedList();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：Java堆栈<code>Stack</code>类已经过时，Java官方推荐使用<code>Deque</code>代替<code>Stack</code>使用。<code>Deque</code>堆栈操作方法：<code>push()</code>，<code>pop()</code>，<code>peek()</code>。</p>\n</blockquote>\n</li>\n</ul>\n<p>此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法存在两种形式：一种形式在操作失败后抛出异常；另一种形式返回一个特殊值（<code>null</code>或<code>false</code>，具体取决于操作）。插入操作的后一种形式是专为有容量限制的<code>Deque</code>实现设计的；在大多数实现中，插入操作不能失败。</p>\n<div class=\"φbt\"><div class=\"φbv\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th>第一个元素（头部）</th>\n<th style=\"padding:0\"></th>\n<th>最后一个元素（尾部）</th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>抛出异常</td>\n<td>特殊值</td>\n<td>抛出异常</td>\n<td>特殊值</td>\n</tr>\n<tr>\n<td>插入</td>\n<td><code>addFirst(e)</code></td>\n<td><code>offerFirst(e)</code></td>\n<td><code>addLast(e)</code></td>\n<td><code>offerLast(e)</code></td>\n</tr>\n<tr>\n<td>删除</td>\n<td><code>removeFirst()</code></td>\n<td><code>pollFirst()</code></td>\n<td><code>removeLast()</code></td>\n<td><code>pollLast()</code></td>\n</tr>\n<tr>\n<td>检查</td>\n<td><code>getFirst()</code></td>\n<td><code>peekFirst()</code></td>\n<td><code>getLast()</code></td>\n<td><code>peekLast()</code></td>\n</tr>\n</tbody>\n</table></div></div><blockquote>\n<p><code>addFirst(e)</code>和<code>offerFirst(e)</code>的区别：由于队列容量限制，当添加失败时会发生一下情况：</p>\n<ul>\n<li><code>addFirst(e)</code>抛出未经检查的异常</li>\n<li><code>offerFirst(e)</code>返回false</li>\n</ul>\n<p>由于<code>ArrayDeque</code>没有容量限制，因此<code>addFirst(e)</code>永远不会发生异常，<code>offerFirst(e)</code>永远返回<code>true</code>，这与<code>LinkedBlockingQueue</code>（由capacity）不同。</p>\n</blockquote>\n<h1 id=\"将deque用作queue\">将Deque用作Queue<a title=\"#将deque用作queue\" href=\"#将deque用作queue\"></a></h1>\n<p>严格执行将元素添加到双端队列的末尾，从双端队列的开头移除元素将得到FIFO（先进先出）的行为。从Queue接口继承的方法完全等效于Deque方法，如下表：</p>\n<div class=\"φbt\"><div class=\"φbv\"><table><thead>\n<tr>\n<th style=\"text-align:center\">Queue方法</th>\n<th style=\"text-align:center\">等效Deque方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>add(e)</code></td>\n<td style=\"text-align:center\"><code>addLast(e)</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>offer(e)</code></td>\n<td style=\"text-align:center\"><code>offerLast(e)</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>remove()</code></td>\n<td style=\"text-align:center\"><code>removeFirst()</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>poll()</code></td>\n<td style=\"text-align:center\"><code>pollFirst()</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>element()</code></td>\n<td style=\"text-align:center\"><code>getFirst()</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>peek()</code></td>\n<td style=\"text-align:center\"><code>peekFirst()</code></td>\n</tr>\n</tbody>\n</table></div></div><h2 id=\"将deque作为栈\">将Deque作为栈<a title=\"#将deque作为栈\" href=\"#将deque作为栈\"></a></h2>\n<p>要实现栈结构的时候，应优先使用此接口而不是遗留<code>Stack</code>类。将双端队列用作堆栈的时候，元素被推入双端队列的开头并从双端队列的开头弹出。堆栈方法完全等效于<code>Deque</code>方法。</p>\n<div class=\"φbt\"><div class=\"φbv\"><table><thead>\n<tr>\n<th style=\"text-align:center\">堆栈方法</th>\n<th style=\"text-align:center\">等效Deque方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>push(e)</code></td>\n<td style=\"text-align:center\"><code>addFirst(e)</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>pop()</code></td>\n<td style=\"text-align:center\"><code>removeFirst()</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>peek()</code></td>\n<td style=\"text-align:center\"><code>peekFirst()</code></td>\n</tr>\n</tbody>\n</table></div></div>","prev":{"title":"关于stringBuilder","link":"2021/03/08/Java/关于stringBuilder"},"next":{"title":"动态规划（Dynamic Programming）","link":"2021/03/08/算法/动态规划（Dynamic-Programming）"},"plink":"http://example.com/2021/03/08/数据结构/双端队列/","toc":[{"id":"双端队列","title":"双端队列","index":"1"},{"id":"将deque用作queue","title":"将Deque用作Queue","index":"2","children":[{"id":"将deque作为栈","title":"将Deque作为栈","index":"2.1"}]}]}