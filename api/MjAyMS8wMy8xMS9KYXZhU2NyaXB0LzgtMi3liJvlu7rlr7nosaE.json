{"title":"8.2 创建对象","date":"2021-03-10T16:00:00.000Z","date_formatted":{"ll":"Mar 11, 2021","L":"03/11/2021","MM-DD":"03-11"},"link":"2021/03/11/JavaScript/8-2-创建对象","tags":["JavaScript"],"categories":["JS Technique"],"updated":"2021-04-24T11:23:18.169Z","content":"<p>[TOC]</p>\n<p><strong>更新日志：</strong></p>\n<p>2021.3.11：P205-213，8.1.1-8.1.5</p>\n<p>2021.3.18：P213-227，8.1.5-8.2.3</p>\n<p>2021.3.20：P227-233，8.2.4</p>\n<p>2021.3.21：P233-238，8.2.5</p>\n<h1 id=\"创建对象\">创建对象<a title=\"#创建对象\" href=\"#创建对象\"></a></h1>\n<p>ECMA6开始正式支持类和继承。</p>\n<h2 id=\"工厂模式\">工厂模式<a title=\"#工厂模式\" href=\"#工厂模式\"></a></h2>\n<p>工厂模式是一种众所周知的<strong>设计模式</strong>，广泛运用于软件工程领域，<strong>用于抽象特定对象的过程</strong>。下面的例子展示了一种<strong>按照特定接口创建对象</strong>的方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    o.name = name;</span><br><span class=\"line\">    o.age = age;</span><br><span class=\"line\">    o.job = job;</span><br><span class=\"line\">    o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person1 = createPerson(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">29</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> person2 = createPerson(<span class=\"string\">&quot;Greg&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>工厂模式虽然可以解决多个类似对象的问题，但没有解决对象标识问题。（即新创建的对象是什么类型）</p>\n<h2 id=\"构造函数模式\">构造函数模式<a title=\"#构造函数模式\" href=\"#构造函数模式\"></a></h2>\n<p>ECMAScript中的<strong>构造函数是用于创建特定类型对象</strong>的，如<code>Object</code>和<code>Array</code>这样的原生构造函数，运行时可以<strong>直接在执行环境中使用</strong>。</p>\n<p>也可以<strong>自定义构造函数</strong>，<strong>以函数的形式为自己的对象定义属性和方法</strong>。e.g. 前面的例子使用构造函数模式可以这么写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.job = job;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">29</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Greg&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>在这里，<code>Person()</code>构造函数代替了<code>createPerson()</code>工厂函数。构造函数和工厂函数内部代码大体相同，但有如下区别：</p>\n<ol>\n<li><strong>没有显式地创建对象</strong></li>\n<li><strong>属性和方法直接赋值给了<code>this</code></strong></li>\n<li><strong>没有<code>return</code></strong></li>\n</ol>\n<p>同时，注意函数名<code>Person</code>的首字母大写了。**按照惯例，构造函数的首字母都是要大写的，非构造函数则以小写字母开头。**这样有助于区分构造函数和普通函数。</p>\n<p>要创建<code>Person</code>的实例，应使用<code>new</code>操作符。以这种方式调用构造函数会执行如下操作：</p>\n<ol>\n<li>\n<p>在内存中新建一个对象</p>\n</li>\n<li>\n<p>在这个对象内部的<code>[[Prototype]]</code>特性被赋值为构造函数的<code>prototype</code>属性</p>\n</li>\n<li>\n<p>构造函数内部的<code>this</code>被赋值为这个新对象</p>\n</li>\n<li>\n<p>执行构造函数内部的代码（给新对象添加属性）</p>\n</li>\n<li>\n<p>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象</p>\n</li>\n</ol>\n<p>上一个例子中，<code>person1</code>和<code>person2</code>分别保存着<code>Person</code>的不同实例。这两个对象都有一个<code>constructor</code>属性指向<code>Person</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.constructor == Person);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.constructor == Person);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p><code>constructor</code>本来是用于表示对象类型的。不过，一般认为<code>instanceof</code>操作符是确定对象类型更可靠的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1 <span class=\"keyword\">instanceof</span> Person);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>**定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。**因为在工厂模式中，无法使用<code>person1 instanceof Person</code>来把实例标识为特定类型。</p>\n<p><strong>所有的自定义对象都继承自Object。</strong></p>\n<p>构造函数不一定要声明成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1.-构造函数也是函数\">1. 构造函数也是函数<a title=\"#1.-构造函数也是函数\" href=\"#1.-构造函数也是函数\"></a></h3>\n<p><strong>构造函数和普通函数唯一的区别就是调用方式不同。任何函数只要使用<code>new</code>操作符就是构造函数，不使用<code>new</code>操作符就是普通函数。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//作为构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);</span><br><span class=\"line\">person.sayName();<span class=\"comment\">//&quot;Nicholas&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//作为函数调用</span></span><br><span class=\"line\">person(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);<span class=\"comment\">//添加到window对象</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.sayName(); <span class=\"comment\">//&quot;Greg&quot;</span></span><br></pre></td></tr></table></figure>\n<p>当把构造函数当普通函数来使用的时候，结果会将属性和方法添加到<code>window</code>对象中。<strong>注意，在调用一个没有明确设置<code>this</code>值的情况下（即没有作为对象的方法调用，或者没有使用<code>call()/apply()</code>调用），<code>this</code>始终指向<code>Global</code>对象。（在浏览器中就是<code>window</code>对象）。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在另一个对象的作用域调用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">Person.call(o, <span class=\"string\">&quot;Kristen&quot;</span>, <span class=\"number\">25</span>, <span class=\"string\">&quot;Nurse&quot;</span>);</span><br><span class=\"line\">o.sayName();<span class=\"comment\">//&quot;Kristen&quot;</span></span><br></pre></td></tr></table></figure>\n<p>上面的调用方式是通过<code>call(),apply()</code>调用函数，同时将特定对象指定为作用域。<strong>这里的调用将对象<code>o</code>指定为<code>Person()</code>内部的<code>this</code>值</strong>，因此执行完函数代码后，所有属性和<code>sayName()</code>方法都会添加到对象<code>o</code>上面。</p>\n<h3 id=\"2.-构造函数的问题\">2. 构造函数的问题<a title=\"#2.-构造函数的问题\" href=\"#2.-构造函数的问题\"></a></h3>\n<p>构造函数的主要问题在于：**其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，<code>person1</code>和<code>person2</code>都有名为<code>sayName()</code>的方法，但这两个方法不是同一个<code>Function</code>实例。**我们知道，**ECMAScript中的函数是对象，因此每次定义函数时，都会初始化一个对象。**逻辑上讲，这个构造函数实际上是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.job =job;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">&quot;console.log(this.name)&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>每个Person实例都会有自己的<code>Function</code>实例用于显示<code>name</code>属性。当然，以这种方式创建函数会带来不同的作用链域和标识符解析。但创建新Function实例的机制是一样的。因此不同实例上的函数虽然同名却不相等。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName == person2.sayName);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p><strong>但是，因为<code>sayName</code>做的是一样的事情，所以没必要定义两个不同的<code>Function</code>实例。况且，<code>this</code>对象可以把函数与对象的绑定推迟到运行时。</strong></p>\n<p><strong>要解决这个问题，可以把函数定义转移到构造函数之外。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.job =job;</span><br><span class=\"line\">    <span class=\"comment\">//这里的sayName属性等于全局sayName()函数</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = sayName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为这一次<code>sayName</code>属性包含的只是一个指向外部函数的指针，所以<code>person1</code>和<code>person2</code>共享了定义在全局作用域上的<code>sayName</code>函数。<strong>这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数，这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型链来解决。</strong></p>\n<h2 id=\"原型模式\">原型模式<a title=\"#原型模式\" href=\"#原型模式\"></a></h2>\n<p>每个函数都会创建一个<code>prototype</code>属性，这个属性是一个<strong>对象</strong>，包含应该由<strong>特定引用类型的实例</strong>共享的属性和方法。实际上，这个对象就是<strong>通过调用构造函数创建的对象的原型</strong>。</p>\n<p>使用原型对象的好处是：<strong>在它上面定义的属性可以被对象实例共享</strong>。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">&quot;Nicholas&quot;</span>;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">27</span>;</span><br><span class=\"line\">Person.prototype.job = <span class=\"string\">&quot;Software Engineer&quot;</span>;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.name);<span class=\"comment\">//Nicholas</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.name);<span class=\"comment\">//Nicholas</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName);<span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype)</span><br><span class=\"line\"><span class=\"comment\">// Person &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   name: &#x27;Nicholas&#x27;,</span></span><br><span class=\"line\"><span class=\"comment\">//   age: 27,</span></span><br><span class=\"line\"><span class=\"comment\">//   job: &#x27;Software Engineer&#x27;,</span></span><br><span class=\"line\"><span class=\"comment\">//   sayName: [Function]</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，所有的属性和<code>sayName()</code>方法都直接添加到了<code>Person</code>的<code>prototype</code>属性上，构造函数体中什么也没有。但这样定义后，<strong>调用构造函数创建的新对象仍然拥有相应的属性和方法</strong>。与构造函数模式不同，<strong>使用这种原型模式定义的属性和方法是所有实例共享的。 因此<code>person1</code>和<code>person2</code>访问的都是相同的属性和相同的<code>sayName()</code>函数。</strong></p>\n<h3 id=\"1.-理解原型\">1. 理解原型<a title=\"#1.-理解原型\" href=\"#1.-理解原型\"></a></h3>\n<p>无论何时，只要创建一个函数，就会<strong>按照特定的规则为这个函数创建一个<code>prototype</code>属性（指向原型对象）</strong>。</p>\n<p>默认情况下，所有原型对象<strong>自动获得一个<code>constructor</code>属性，指回与之关联的构造函数</strong>。</p>\n<p>对前面的例子而言，<code>Person.prototype.constructor</code>指向<code>Person</code>。然后，因构造函数而异，可能会给原型对象添加其它属性和方法。</p>\n<p>在自定义构造函数时，原型对象默认只会获得<code>constructor</code>属性，其它所有方法都继承自Object。</p>\n<p>每次调用构造函数创建一个新实例，这个实例内部<code>[[Prototype]]</code>指针就会被赋值为构造函数的原型对象。</p>\n<p>脚本中没有访问这个<code>[[Prototype]]</code>特性的标准方式，但Firefox，Safari和Chrome会在每个对象上暴露<code>__proto__</code>属性，通过这个属性可以访问对象的原型。</p>\n<p><strong>关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//声明之后，构造函数就有了一个与之关联的原型对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> Person.prototype);<span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype);<span class=\"comment\">//打印出下面的原型对象</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\tconstructor: ƒ Person()</span></span><br><span class=\"line\"><span class=\"comment\">//\t__proto__: Object</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如前所述，构造函数有一个<code>prototype</code>属性引用其原型对象，而这个原型对象也有一个<code>constructor</code>属性引用这个构造函数；换句话说，<strong>两者互相引用</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.constructor === Person); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>正常的原型链都会<strong>终止于<code>Object</code>的原型对象</strong>，<code>Object</code>原型的原型是<code>null</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.__proto__.constructor === <span class=\"built_in\">Object</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.__proto__.__proto__ === <span class=\"literal\">null</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.__proto__);</span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     constructor: ƒ Object(),</span></span><br><span class=\"line\"><span class=\"comment\">//     hasOwnProperty: ƒ hasOwnProperty(),</span></span><br><span class=\"line\"><span class=\"comment\">//     isPrototypeOf: ƒ isPrototypeOf(),</span></span><br><span class=\"line\"><span class=\"comment\">//     propertyIsEnumerable: ƒ propertyIsEnumerable(),</span></span><br><span class=\"line\"><span class=\"comment\">//     toLocaleString: ƒ toLocaleString(),</span></span><br><span class=\"line\"><span class=\"comment\">//     toString: ƒ toString(),</span></span><br><span class=\"line\"><span class=\"comment\">//     valueOf: ƒ valueOf(),</span></span><br><span class=\"line\"><span class=\"comment\">//     __defineGetter__: ƒ __defineGetter__(),</span></span><br><span class=\"line\"><span class=\"comment\">//     __defineSetter__: ƒ __defineSetter__(),</span></span><br><span class=\"line\"><span class=\"comment\">//     __lookupGetter__: ƒ __lookupGetter__(),</span></span><br><span class=\"line\"><span class=\"comment\">//     __lookupSetter__: ƒ __lookupSetter__(),</span></span><br><span class=\"line\"><span class=\"comment\">//     get __proto__: ƒ __proto__(),</span></span><br><span class=\"line\"><span class=\"comment\">//     set __proto__: ƒ __proto__()</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>构造函数、原型对象和实例是3个完全不同的对象</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1 !== Person); <span class=\"comment\">//true，实例与构造函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1 !== Person.prototype); <span class=\"comment\">//true，实例与原型对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype !== Person); <span class=\"comment\">//true，原型对象与构造函数</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><strong>实例通过<code>__proto__</code>连接到原型对象，它实际指向<code>[[prototype]]</code></strong></p>\n</li>\n<li>\n<p><strong>构造函数通过<code>prototype</code>属性链接到原型对象</strong></p>\n</li>\n<li>\n<p><strong>实例与构造函数没有直接联系，与原型对象有直接联系</strong></p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.__proto__ === Person.prototype); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.__proto__.constructor === Person)l <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>同一个构造函数创建的两个实例共享一个原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.__proto__ === person2.__proto__); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>可以使用<code>instance</code>检查实例的原型链中是否包含指定构造函数的原型</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/andrewyuanyuan/blog-image/img/006SqI8Ply1gooj740jvmj30rx0g00sq.jpg\" alt=\"2021-03-19_003710.png\" class=\"φbs\"></p>\n<ul>\n<li>\n<p><code>Person.prototype</code>指向原型对象，原型对象包含<code>constructor</code>属性和其他后来添加的属性</p>\n</li>\n<li>\n<p><code>Person.prototype.constructor</code>指回<code>Person</code>构造函数</p>\n</li>\n<li>\n<p><code>Person</code>的两个实例<code>person1</code>和<code>person2</code>都只有一个内部属性指回<code>Person.prototype</code>，且二者都与构造函数没有直接关联。另外，虽然这两个实例都没有属性和方法，但<code>person1.sayName()</code>可以正常调用。这是由于<strong>对象属性查找机制</strong>的原因。</p>\n</li>\n</ul>\n<p>虽然不是所有实现都对外暴露了<code>[[Prototype]]</code>，但可以使用<code>isPrototypeOf()</code>方法确定两个对象之间的这种关系。本质上，<code>isPrototypeOf()</code>会在<strong>传入参数的<code>[[Prototype]]</code>指向调用它的对象</strong>时返回<code>true</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.isPrototypeOf(person1));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.isPrototypeOf(person2));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>因为<code>person1</code>和<code>person2</code>两个例子内部都有链接指向<code>Person.prototype</code>，所以结果都返回<code>true</code>。</p>\n<h4 id=\"object.getprototypeof()\">Object.getPrototypeOf()<a title=\"#object.getprototypeof()\" href=\"#object.getprototypeof()\"></a></h4>\n<p><code>ECMAScript</code>的<code>Object</code>类型有一个方法叫<code>Object.getPrototypeOf()</code>，返回参数的内部特性<code>[[Prototype]]</code>的值。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(person1));</span><br><span class=\"line\"><span class=\"comment\">// Person &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     name: &#x27;Nicholas&#x27;,</span></span><br><span class=\"line\"><span class=\"comment\">//     age: 29,</span></span><br><span class=\"line\"><span class=\"comment\">//     job: &#x27;Software Engineer&#x27;,</span></span><br><span class=\"line\"><span class=\"comment\">//     sayName: [Function]</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(person1).name);<span class=\"comment\">//Nicholas</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(person1) === Person.prototype);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用<code>Object.getPrototypeOf()</code>可以方便地获取一个对象的原型，而这在通过原型实现继承时显得尤为重要。</strong></p>\n<h4 id=\"object.setprototypeof()\">Object.setPrototypeOf()<a title=\"#object.setprototypeof()\" href=\"#object.setprototypeof()\"></a></h4>\n<p><code>Object</code>类型还有一个<code>setPrototypeOf()</code>方法，可以向实例的私有特性<code>[[Prototype]]</code>写入一个新值。这样就可以重写一个对象的原型继承关系。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> biped = &#123;</span><br><span class=\"line\">    numLegs: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&#x27;Matt&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(person, biped);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name);<span class=\"comment\">//Matt</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.numLegs);<span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(person)===biped);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意</strong>：<strong><code>Object.setPrototypeOf()</code>可能会严重影响代码性能</strong>，在Mozilla文档中说得很清楚：<strong>在所有浏览器和JavaScript 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行<code>Object.setPrototypeOf()</code>语句那么简单，而是会涉及所有访问了那些修改过<code>[[Prototype]]</code>的对象的代码。</strong></p>\n</blockquote>\n<p>为避免使用<code>Object.setPrototypeOf()</code>可能造成的性能下降，可以通过<code>Object.create()</code>来创建一个新对象，同时为其指定原型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> biped = &#123;</span><br><span class=\"line\">    numLegs:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"built_in\">Object</span>.create(biped);</span><br><span class=\"line\">person.name = <span class=\"string\">&quot;Matt&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name);<span class=\"comment\">//Matt</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.numLegs);<span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(person)===biped);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2.-原型层级\">2. 原型层级<a title=\"#2.-原型层级\" href=\"#2.-原型层级\"></a></h3>\n<p>在通过对象访问属性时，会按照这个属性的名称开始搜索。</p>\n<p>搜索开始于对象实例本身，如果在这个实例上发现了给定的名称，则返回该名称对应的值。</p>\n<p>如果没有找到这个属性，则搜索回沿着指针进入原型对象，然后在原型对象上找到属性后，再返回相应的值。</p>\n<p>这就是原型用于在多个对象实例间共享属性和方法的原理。</p>\n<p>e.g. 在调用person1.sayName()的时候，JavaScript引擎首先询问：person1实例有sayName属性吗？答案是没有；然后继续搜索并询问，person1的原型有sayName属性吗，答案是有并返回保存在原型上的这个函数。</p>\n<p>虽然<strong>可以通过实例读取原型对象上的值，但不可能通过实例重写这些值</strong>。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的值。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">&quot;Nicholas&quot;</span>;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">Person.prototype.job = <span class=\"string\">&quot;Software Engineer&quot;</span>;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">let</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person1.name = <span class=\"string\">&#x27;Greg&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.name);<span class=\"comment\">//Greg，来自实例</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.name);<span class=\"comment\">//Nocholas，来自原型</span></span><br></pre></td></tr></table></figure>\n<p>**只要给对象实例添加一个属性，这个属性就会遮蔽（shadow）原型对象上的同名属性。**也就是最然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为<code>null</code>，也不会恢复它与原型的联系。不过，使用delete操作符可以完全删除实例上的这个属性，从而让标识符能够继续搜索原型对象。接上例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> person1.name;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.name);<span class=\"comment\">//Nocholas，来自原型</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"hasownproperty()\">hasOwnProperty()<a title=\"#hasownproperty()\" href=\"#hasownproperty()\"></a></h4>\n<p>继承自Object的方法<code>hasOwnProperty()</code>用于确定某个属性是<strong>在实例上还是在原型对象上</strong>。它会在属性存在于调用它的对象实例上时返回<code>true</code>。接上例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//上面删除了person1的属性name，现在person1的name来自原型对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.hasOwnProperty(<span class=\"string\">&quot;name&quot;</span>));<span class=\"comment\">//false</span></span><br><span class=\"line\">person1.name = <span class=\"string\">&#x27;Greg&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.name);<span class=\"comment\">//Greg，来自实例</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.hasOwnProperty(<span class=\"string\">&quot;name&quot;</span>));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>由此，通过hasOwnProperty可以很清楚地看到访问的时实例属性还是原型属性。调用<code>person1.hasOwnProperty(&quot;name&quot;)</code>可以只在重写<code>person1</code>上<code>name</code>属性的情况下才返回<code>true</code>，表明此时<code>name</code>是一个实例属性。</p>\n<blockquote>\n<p>ECMAScript的<code>Object.getOwnPropertyDescriptor()</code>方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用<code>Object.getOwnProperty-Descriptor()</code>。</p>\n</blockquote>\n<h3 id=\"3.-原型和in操作符\">3. 原型和in操作符<a title=\"#3.-原型和in操作符\" href=\"#3.-原型和in操作符\"></a></h3>\n<p>有两种方式使用<code>in</code>操作符：</p>\n<ol>\n<li>\n<p>单独使用</p>\n<p>在单独使用时，<code>in</code>操作符会在<strong>可以通过对象访问指定属性时返回<code>true</code>，无论该属性是在实例上还是在原型上</strong>。</p>\n<p>如果要确定某个属性是否存在于原型上，则可以像下面这样同时使用<code>hasOwnProperty()</code>和<code>in</code>操作符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hasPropertypeProperty</span>(<span class=\"params\">object, name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class=\"keyword\">in</span> object);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要通过对象可以访问，<code>in</code>操作符就返回<code>true</code>，而<code>hasOwnProperty()</code>只有属性存在于实例上时才返回<code>true</code>。因此，只要<code>in</code>操作符返回<code>true</code>且<code>hasOwnProperty()</code>返回<code>false</code>，就说明该属性是一个原型属性。</p>\n</li>\n<li>\n<p>在<code>for-in</code>循环中使用</p>\n<p>在<code>for-in</code>循环中使用<code>in</code>操作符时，<strong>可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性</strong>。遮蔽原型中不可枚举（<code>[[Enumerable]]</code>特性为<code>false</code>）属性的实例也会在<code>for-in</code>循环中返回，因为默认情况下开发者定义的属性都是可枚举的。</p>\n</li>\n</ol>\n<h4 id=\"object.keys()\">Object.keys()<a title=\"#object.keys()\" href=\"#object.keys()\"></a></h4>\n<p>要<strong>获得对象上所有可枚举的实例属性</strong>，可以使用<code>Object.keys()</code>方法，这个方法接收一个对象作为参数，<strong>返回包含该对象所有可枚举属性名称的字符串数组</strong>。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">&quot;Nicholas&quot;</span>;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">Person.prototype.job = <span class=\"string\">&quot;Software Engineer&quot;</span>;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> keys = <span class=\"built_in\">Object</span>.keys(Person.prototype);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(keys);<span class=\"comment\">//[ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p1.name = <span class=\"string\">&#x27;Rob&#x27;</span>;</span><br><span class=\"line\">p1.age = <span class=\"number\">31</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1keys = <span class=\"built_in\">Object</span>.keys(p1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1keys);<span class=\"comment\">//[ &#x27;name&#x27;, &#x27;age&#x27; ]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"object.getpropertynames()\">Object.getPropertyNames()<a title=\"#object.getpropertynames()\" href=\"#object.getpropertynames()\"></a></h4>\n<p>如果想要列出所有实例属性，不论是否枚举，都可以使用<code>Object.getPropertyNames()</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> keys = <span class=\"built_in\">Object</span>.getOwnPropertyNames(Person.prototype);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(keys);<span class=\"comment\">//[ &#x27;constructor&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]</span></span><br></pre></td></tr></table></figure>\n<p>注意，返回的结果中包含了一个不可枚举的属性<code>constructor</code>。</p>\n<p><code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>在适当的时候都可用来代替<code>for-in</code>循环。</p>\n<h4 id=\"针对符号的object.getownpropertysymbols()\">针对符号的Object.getOwnPropertySymbols()<a title=\"#针对符号的object.getownpropertysymbols()\" href=\"#针对符号的object.getownpropertysymbols()\"></a></h4>\n<p>和<code>Object.getPropertyNames()</code>是兄弟方法，因为以符号为键的属性没有名称的概念。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> k1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;k1&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> k2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;k2&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">    [k1]:<span class=\"string\">&#x27;k1&#x27;</span>,</span><br><span class=\"line\">    [k2]:<span class=\"string\">&#x27;k2&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertySymbols(o));<span class=\"comment\">//[ Symbol(k1), Symbol(k2) ]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4.-属性枚举顺序\">4. 属性枚举顺序<a title=\"#4.-属性枚举顺序\" href=\"#4.-属性枚举顺序\"></a></h3>\n<p><code>for-in</code>循环、<code>Objext.keys()</code> 、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>以及<code>Object.assign()</code>在属性枚举方面有很大的区别。</p>\n<ul>\n<li><code>for-in</code>循环和<code>Object.keys()</code>的枚举顺序是<strong>不确定</strong>的，取决于JavaScript引擎，可能因浏览器而异。</li>\n<li><code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>和<code>Object.assign()</code>的枚举顺序是<strong>确定性</strong>的。<strong>先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> k1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;k1&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> k2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;k2&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">    first:<span class=\"string\">&#x27;first&#x27;</span>,</span><br><span class=\"line\">    [k1]:<span class=\"string\">&#x27;sym2&#x27;</span>,</span><br><span class=\"line\">    second:<span class=\"string\">&#x27;second&#x27;</span>,</span><br><span class=\"line\">    <span class=\"number\">0</span>:<span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">o[k2] = <span class=\"string\">&#x27;sym2&#x27;</span>;</span><br><span class=\"line\">o[<span class=\"number\">3</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">o.third = <span class=\"string\">&#x27;third&#x27;</span>;</span><br><span class=\"line\">o[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(o));</span><br><span class=\"line\"><span class=\"comment\">//[ &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertySymbols(o));</span><br><span class=\"line\"><span class=\"comment\">//[ Symbol(k1), Symbol(k2) ]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"对象迭代\">对象迭代<a title=\"#对象迭代\" href=\"#对象迭代\"></a></h2>\n<p>在JavaScript有史以来的大部分时间里，迭代对象属性都是一个难题。ECMAScript 2017新增了两个静态方法，用于将对象内容转换为<strong>序列化的，可迭代的</strong>格式。</p>\n<p>这两个静态方法：**<code>Object.values()</code>和<code>Object.entries()</code>**接受一个对象，返回它们内容的数组。</p>\n<ul>\n<li><code>Object.values()</code>返回对象值的数组</li>\n<li><code>Object.entries()</code>放回键\\值对的数组</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">    foo:<span class=\"string\">&#x27;bar&#x27;</span>,</span><br><span class=\"line\">    baz:<span class=\"number\">1</span>,</span><br><span class=\"line\">    qux:&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.values(o));</span><br><span class=\"line\"><span class=\"comment\">//[ &#x27;bar&#x27;, 1, &#123;&#125; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.entries(o));</span><br><span class=\"line\"><span class=\"comment\">//[ [ &#x27;foo&#x27;, &#x27;bar&#x27; ], [ &#x27;baz&#x27;, 1 ], [ &#x27;qux&#x27;, &#123;&#125; ] ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>.values(o)[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"comment\">//string</span></span><br></pre></td></tr></table></figure>\n<p>注意，非字符串的属性会被转换为字符串输出，如上面的<code>1</code>，且这两个方法执行的是对象的浅复制。同时，符号属性会被忽略。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;</span><br><span class=\"line\">    [sym]:<span class=\"string\">&#x27;foo&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.values(o));<span class=\"comment\">//[]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.entries(o));<span class=\"comment\">//[]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1.-其它原型语法\">1. 其它原型语法<a title=\"#1.-其它原型语法\" href=\"#1.-其它原型语法\"></a></h3>\n<p>为了避免每次定义一个属性或方法都会把<code>Person.prototype</code>重写一遍，也为了视觉上更好地封装原型功能，<strong>直接通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法</strong>。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&#x27;Nicholas&#x27;</span>,</span><br><span class=\"line\">    age:<span class=\"number\">29</span>,</span><br><span class=\"line\">    job:<span class=\"string\">&#x27;Software Engineer&#x27;</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">sayName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，<code>Person.prototype</code>被设置为<strong>等于一个通过对象字面量创建的新对象</strong>。</p>\n<p>最终结果是一样的，但是一个问题：这样重写之后，<code>Person.prototype</code>的<code>constructor</code>属性就不指向<code>Person</code>了。在创建函数时，也会创建它的<code>prototype</code>对象，同时会自动给这个原型的<code>constructor</code>属性赋值。而上面的写法完全重写了默认的<code>prototype</code>对象，因此其<code>constructor</code>属性也指向了完全不同的新对象（<code>Object</code>构造函数），不再指向原来的构造函数。<strong>虽然<code>instanceof</code>操作符还能可靠地返回值，但我们不能再依赖<code>constructor</code>属性来识别类型了。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> friend = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friend <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friend <span class=\"keyword\">instanceof</span> Person);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friend.constructor === Person);<span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friend.constructor === <span class=\"built_in\">Object</span>);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>当然，如果<code>constructor</code>的值很重要，则可以**像下面这样重写原型对象时专门设置一下它的值。**e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"title\">constructor</span>: <span class=\"title\">Person</span>,</span><br><span class=\"line\">    <span class=\"title\">name</span>: &#x27;<span class=\"title\">Nicholas</span>&#x27;,</span><br><span class=\"line\">    <span class=\"title\">age</span>:29,</span><br><span class=\"line\">    <span class=\"title\">job</span>:&#x27;<span class=\"title\">Software</span> <span class=\"title\">Engineer</span>&#x27;,</span><br><span class=\"line\">    <span class=\"title\">sayName</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是，需要注意以这种方式恢复<code>constructor</code>属性会创建一个<code>[[Enumberable]]</code>为<code>true</code>的属性。而原生<code>constructor</code>属性默认是不可枚举的。因此，如果你使用的是兼容ECMAScript的JavaScript引擎，那可能会改为使用<code>Object.defineProperty()</code>方法来定义<code>constructor</code>属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"title\">constructor</span>: <span class=\"title\">Person</span>,</span><br><span class=\"line\">    <span class=\"title\">name</span>: &#x27;<span class=\"title\">Nicholas</span>&#x27;,</span><br><span class=\"line\">    <span class=\"title\">age</span>:29,</span><br><span class=\"line\">    <span class=\"title\">job</span>:&#x27;<span class=\"title\">Software</span> <span class=\"title\">Engineer</span>&#x27;,</span><br><span class=\"line\">    <span class=\"title\">sayName</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//恢复constructor属性</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Person.prototype, <span class=\"string\">&quot;constructor&quot;</span>, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    value:Person</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"2.-原型的动态性\">2. 原型的动态性<a title=\"#2.-原型的动态性\" href=\"#2.-原型的动态性\"></a></h3>\n<p>因为<strong>从原型上搜索值得过程是动态的</strong>，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> friend = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person.prototype.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Hi&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">friend.sayHi();<span class=\"comment\">//Hi</span></span><br></pre></td></tr></table></figure>\n<p>之所以会这样，主要原因是<strong>实例与原型之间松散的关系</strong>。实例和原型之间的链接就是简单的指针，而不是保存的副本，所以会在原型上找到<code>sayHi</code>属性并返回这个属性保存的函数。</p>\n<p>**虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两回事。**实例的<code>[[prototype]]</code>指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> friend = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&#x27;Nicholas&#x27;</span>,</span><br><span class=\"line\">    age:<span class=\"number\">29</span>,</span><br><span class=\"line\">    job:<span class=\"string\">&#x27;Software Engineer&#x27;</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">sayName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">friend.sayName();<span class=\"comment\">//错误</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> friend1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">friend1.sayName();<span class=\"comment\">//Nicholas</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，<code>Person</code>的新实例是在重写原型对象之前创建的。在调用<code>friend.sayName()</code>的时候，会导致错误。这是因为<code>friend</code>指向的原型还是最初的原型，而这个原型上并没有<code>sayName</code>属性。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/andrewyuanyuan/blog-image/img/006SqI8Ply1gordsx7uvtj30my0k3t8s.jpg\" alt=\"2021-03-21_114808.png\" class=\"φbs\"></p>\n<p><strong>重写构造函数上的原型之后再创建的实例才会引用新原型，而此前创建的实例仍然会引用最初的原型。</strong></p>\n<h3 id=\"3.-原生对象原型\">3. 原生对象原型<a title=\"#3.-原生对象原型\" href=\"#3.-原生对象原型\"></a></h3>\n<p>原型模式之所以重要，不仅体现在自定义类型上，而且还因为**它也是实现所有原生引用类型的模式。**所有原生引用类型的构造函数（包括<code>Object</code>、<code>Array</code>、<code>String</code>等）都在原型上定义了实例方法。</p>\n<p>e.g.数组实例的<code>sort()</code>方法就是<code>Array.prototype</code>上定义的，而字符串包装对象的<code>subString()</code>方法也是在<code>String.prototype</code>上定义的，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.sort);<span class=\"comment\">//function</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">String</span>.prototype.substring);<span class=\"comment\">//function</span></span><br></pre></td></tr></table></figure>\n<p>**通过原生对象的原型可以取得所有默认方法的应用，也可以给原生类型的实例定义新的方法。**可以像修改自定义对象原型那样修改原生对象原型，因此可以随时添加方法。e.g. 下面的代码就给<code>String</code>原始值包装类型的实例添加了一个<code>startWith()</code>方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.prototype.startsWith = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.indexOf(text) === <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> msg = <span class=\"string\">&#x27;Hello world!&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(msg.startsWith(<span class=\"string\">&quot;Hello&quot;</span>));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>因为这个方法是被定义在<code>String.prototype</code>上，所以当前环境下所有的字符串都可以使用这个方法。<code>msg</code>是个字符串，在读取它的属性时，后台会自动创建<code>String</code>的包装实例，从而找到并调用<code>startsWith()</code>方法。</p>\n<blockquote>\n<p>尽管可以这么做，但并不推荐在产品环境修改原生对象类型。因为可能会造成误会、引发命名冲突（比如一个名称在某个浏览器中不存在，在另一个实现中却存在）和意外重写原生的方法。<strong>推荐的做法是创建一个自定义的类，继承原生类型。</strong></p>\n</blockquote>\n<h3 id=\"4.-原型的问题\">4. 原型的问题<a title=\"#4.-原型的问题\" href=\"#4.-原型的问题\"></a></h3>\n<p>原型模式也存在着一些问题。首先，它弱化了向构造函数传递初始化参数的能力，回导致所有实例默认都取得相同的属性值。（会带来不便，但不是最大的问题）。</p>\n<p>原型模式最主要的问题在于<strong>共享特性</strong>。我们知道，原型上的所有属性是在实例间共享的，这对函数来说比较合适。另外包含原始值的属性也还好，如前面的例子所示，可以通过在实例上添加同名属性来简单地遮蔽原型上的属性。真正的问题来自<strong>包含引用值的属性</strong>。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"title\">constructor</span>: <span class=\"title\">Person</span>,</span><br><span class=\"line\">    <span class=\"title\">name</span>:&quot;<span class=\"title\">Nicholas</span>&quot;,</span><br><span class=\"line\">    <span class=\"title\">age</span>:29,</span><br><span class=\"line\">    <span class=\"title\">job</span>:&quot;<span class=\"title\">Software</span> <span class=\"title\">Engineer</span>&quot;,</span><br><span class=\"line\">    <span class=\"title\">friends</span>:[&quot;<span class=\"title\">Shelby</span>&quot;,&quot;<span class=\"title\">Court</span>&quot;],</span><br><span class=\"line\">    <span class=\"title\">sayName</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">let</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person1.friends.push(<span class=\"string\">&quot;Van&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.friends);<span class=\"comment\">//[ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.friends);<span class=\"comment\">//[ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.friends === person2.friends);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>由于这个<code>friends</code>属性存在于<code>Person.prototype</code>而非<code>person1</code>上，新加的这个字符串也会在（指向同一个数组的）<code>person2.friends</code>上反映出来。</p>\n<p>如果这是有意在多个实例间共享数组，那没问题。<strong>但一般来说，不同的实例应该有属于自己的属性副本，这就是实际开发中通常不单独使用原型模式的原因。</strong></p>\n","prev":{"title":"每日一题：LC200 岛屿数量","link":"2021/03/11/刷题日记/每日一题：LC200 岛屿数量"},"next":{"title":"Log","link":"2021/03/10/刷题日记/log"},"plink":"http://example.com/2021/03/11/JavaScript/8-2-创建对象/","toc":[{"id":"创建对象","title":"创建对象","index":"1","children":[{"id":"工厂模式","title":"工厂模式","index":"1.1"},{"id":"构造函数模式","title":"构造函数模式","index":"1.2","children":[{"id":"1.-构造函数也是函数","title":"1. 构造函数也是函数","index":"1.2.1"},{"id":"2.-构造函数的问题","title":"2. 构造函数的问题","index":"1.2.2"}]},{"id":"原型模式","title":"原型模式","index":"1.3","children":[{"id":"1.-理解原型","title":"1. 理解原型","index":"1.3.1"},{"id":"2.-原型层级","title":"2. 原型层级","index":"1.3.2"},{"id":"3.-原型和in操作符","title":"3. 原型和in操作符","index":"1.3.3"},{"id":"4.-属性枚举顺序","title":"4. 属性枚举顺序","index":"1.3.4"}]},{"id":"对象迭代","title":"对象迭代","index":"1.4","children":[{"id":"1.-其它原型语法","title":"1. 其它原型语法","index":"1.4.1"},{"id":"2.-原型的动态性","title":"2. 原型的动态性","index":"1.4.2"},{"id":"3.-原生对象原型","title":"3. 原生对象原型","index":"1.4.3"},{"id":"4.-原型的问题","title":"4. 原型的问题","index":"1.4.4"}]}]}]}