{"title":"8.2 创建对象","date":"2021-03-10T16:00:00.000Z","date_formatted":{"ll":"Mar 11, 2021","L":"03/11/2021","MM-DD":"03-11"},"link":"2021/03/11/JavaScript/8-2-创建对象","tags":["JavaScript"],"categories":["JS Technique"],"updated":"2021-03-18T16:38:40.924Z","content":"<p><strong>更新日志：</strong></p>\n<p>2021.3.11：P205-213，8.1.1-8.1.5</p>\n<h1 id=\"创建对象\">创建对象<a title=\"#创建对象\" href=\"#创建对象\"></a></h1>\n<p>ECMA6开始正式支持类和继承。</p>\n<h2 id=\"工厂模式\">工厂模式<a title=\"#工厂模式\" href=\"#工厂模式\"></a></h2>\n<p>工厂模式是一种众所周知的<strong>设计模式</strong>，广泛运用于软件工程领域，<strong>用于抽象特定对象的过程</strong>。下面的例子展示了一种<strong>按照特定接口创建对象</strong>的方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    o.name = name;</span><br><span class=\"line\">    o.age = age;</span><br><span class=\"line\">    o.job = job;</span><br><span class=\"line\">    o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person1 = createPerson(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">29</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> person2 = createPerson(<span class=\"string\">&quot;Greg&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>工厂模式虽然可以解决多个类似对象的问题，但没有解决对象标识问题。（即新创建的对象是什么类型）</p>\n<h2 id=\"构造函数模式\">构造函数模式<a title=\"#构造函数模式\" href=\"#构造函数模式\"></a></h2>\n<p>ECMAScript中的<strong>构造函数是用于创建特定类型对象</strong>的，如<code>Object</code>和<code>Array</code>这样的原生构造函数，运行时可以<strong>直接在执行环境中使用</strong>。</p>\n<p>也可以<strong>自定义构造函数</strong>，<strong>以函数的形式为自己的对象定义属性和方法</strong>。e.g. 前面的例子使用构造函数模式可以这么写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.job = job;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">29</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Greg&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>在这里，<code>Person()</code>构造函数代替了<code>createPerson()</code>工厂函数。构造函数和工厂函数内部代码大体相同，但有如下区别：</p>\n<ol>\n<li><strong>没有显式地创建对象</strong></li>\n<li><strong>属性和方法直接赋值给了<code>this</code></strong></li>\n<li><strong>没有<code>return</code></strong></li>\n</ol>\n<p>同时，注意函数名<code>Person</code>的首字母大写了。**按照惯例，构造函数的首字母都是要大写的，非构造函数则以小写字母开头。**这样有助于区分构造函数和普通函数。</p>\n<p>要创建<code>Person</code>的实例，应使用<code>new</code>操作符。以这种方式调用构造函数会执行如下操作：</p>\n<ol>\n<li>\n<p>在内存中新建一个对象</p>\n</li>\n<li>\n<p>在这个对象内部的<code>[[Prototype]]</code>特性被赋值为构造函数的<code>prototype</code>属性</p>\n</li>\n<li>\n<p>构造函数内部的<code>this</code>被赋值为这个新对象</p>\n</li>\n<li>\n<p>执行构造函数内部的代码（给新对象添加属性）</p>\n</li>\n<li>\n<p>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象</p>\n</li>\n</ol>\n<p>上一个例子中，<code>person1</code>和<code>person2</code>分别保存着<code>Person</code>的不同实例。这两个对象都有一个<code>constructor</code>属性指向<code>Person</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.constructor == Person);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.constructor == Person);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p><code>constructor</code>本来是用于表示对象类型的。不过，一般认为<code>instanceof</code>操作符是确定对象类型更可靠的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1 <span class=\"keyword\">instanceof</span> Person);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>**定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。**因为在工厂模式中，无法使用<code>person1 instanceof Person</code>来把实例标识为特定类型。</p>\n<p><strong>所有的自定义对象都继承自Object。</strong></p>\n<p>构造函数不一定要声明成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1.-构造函数也是函数\">1. 构造函数也是函数<a title=\"#1.-构造函数也是函数\" href=\"#1.-构造函数也是函数\"></a></h3>\n<p><strong>构造函数和普通函数唯一的区别就是调用方式不同。任何函数只要使用<code>new</code>操作符就是构造函数，不使用<code>new</code>操作符就是普通函数。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//作为构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);</span><br><span class=\"line\">person.sayName();<span class=\"comment\">//&quot;Nicholas&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//作为函数调用</span></span><br><span class=\"line\">person(<span class=\"string\">&quot;Nicholas&quot;</span>, <span class=\"number\">27</span>, <span class=\"string\">&quot;Software Engineer&quot;</span>);<span class=\"comment\">//添加到window对象</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.sayName(); <span class=\"comment\">//&quot;Greg&quot;</span></span><br></pre></td></tr></table></figure>\n<p>当把构造函数当普通函数来使用的时候，结果会将属性和方法添加到<code>window</code>对象中。<strong>注意，在调用一个没有明确设置<code>this</code>值的情况下（即没有作为对象的方法调用，或者没有使用<code>call()/apply()</code>调用），<code>this</code>始终指向<code>Global</code>对象。（在浏览器中就是<code>window</code>对象）。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在另一个对象的作用域调用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">Person.call(o, <span class=\"string\">&quot;Kristen&quot;</span>, <span class=\"number\">25</span>, <span class=\"string\">&quot;Nurse&quot;</span>);</span><br><span class=\"line\">o.sayName();<span class=\"comment\">//&quot;Kristen&quot;</span></span><br></pre></td></tr></table></figure>\n<p>上面的调用方式是通过<code>call(),apply()</code>调用函数，同时将特定对象指定为作用域。<strong>这里的调用将对象<code>o</code>指定为<code>Person()</code>内部的<code>this</code>值</strong>，因此执行完函数代码后，所有属性和<code>sayName()</code>方法都会添加到对象<code>o</code>上面。</p>\n<h3 id=\"2.-构造函数的问题\">2. 构造函数的问题<a title=\"#2.-构造函数的问题\" href=\"#2.-构造函数的问题\"></a></h3>\n<p>构造函数的主要问题在于：**其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，<code>person1</code>和<code>person2</code>都有名为<code>sayName()</code>的方法，但这两个方法不是同一个<code>Function</code>实例。**我们知道，**ECMAScript中的函数是对象，因此每次定义函数时，都会初始化一个对象。**逻辑上讲，这个构造函数实际上是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.job =job;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">&quot;console.log(this.name)&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>每个Person实例都会有自己的<code>Function</code>实例用于显示<code>name</code>属性。当然，以这种方式创建函数会带来不同的作用链域和标识符解析。但创建新Function实例的机制是一样的。因此不同实例上的函数虽然同名却不相等。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName == person2.sayName);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p><strong>但是，因为<code>sayName</code>做的是一样的事情，所以没必要定义两个不同的<code>Function</code>实例。况且，<code>this</code>对象可以把函数与对象的绑定推迟到运行时。</strong></p>\n<p><strong>要解决这个问题，可以把函数定义转移到构造函数之外。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.job =job;</span><br><span class=\"line\">    <span class=\"comment\">//这里的sayName属性等于全局sayName()函数</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = sayName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为这一次<code>sayName</code>属性包含的只是一个指向外部函数的指针，所以<code>person1</code>和<code>person2</code>共享了定义在全局作用域上的<code>sayName</code>函数。<strong>这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数，这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型链来解决。</strong></p>\n<h2 id=\"原型模式\">原型模式<a title=\"#原型模式\" href=\"#原型模式\"></a></h2>\n<p>每个函数都会创建一个<code>prototype</code>属性，这个属性是一个<strong>对象</strong>，包含应该由<strong>特定引用类型的实例</strong>共享的属性和方法。实际上，这个对象就是<strong>通过调用构造函数创建的对象的原型</strong>。</p>\n<p>使用原型对象的好处是：<strong>在它上面定义的属性可以被对象实例共享</strong>。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">&quot;Nicholas&quot;</span>;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">27</span>;</span><br><span class=\"line\">Person.prototype.job = <span class=\"string\">&quot;Software Engineer&quot;</span>;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.name);<span class=\"comment\">//Nicholas</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.name);<span class=\"comment\">//Nicholas</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName);<span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype)</span><br><span class=\"line\"><span class=\"comment\">// Person &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   name: &#x27;Nicholas&#x27;,</span></span><br><span class=\"line\"><span class=\"comment\">//   age: 27,</span></span><br><span class=\"line\"><span class=\"comment\">//   job: &#x27;Software Engineer&#x27;,</span></span><br><span class=\"line\"><span class=\"comment\">//   sayName: [Function]</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，所有的属性和<code>sayName()</code>方法都直接添加到了<code>Person</code>的<code>prototype</code>属性上，构造函数体中什么也没有。但这样定义后，<strong>调用构造函数创建的新对象仍然拥有相应的属性和方法</strong>。与构造函数模式不同，<strong>使用这种原型模式定义的属性和方法是所有实例共享的。 因此<code>person1</code>和<code>person2</code>访问的都是相同的属性和相同的<code>sayName()</code>函数。</strong></p>\n<h3 id=\"1.-理解原型\">1. 理解原型<a title=\"#1.-理解原型\" href=\"#1.-理解原型\"></a></h3>\n<p>无论何时，只要创建一个函数，就会<strong>按照特定的规则为这个函数创建一个<code>prototype</code>属性（指向原型对象）</strong>。</p>\n<p>默认情况下，所有原型对象<strong>自动获得一个<code>constructor</code>属性，指回与之关联的构造函数</strong>。</p>\n<p>对前面的例子而言，<code>Person.prototype.constructor</code>指向<code>Person</code>。然后，因构造函数而异，可能会给原型对象添加其它属性和方法。</p>\n<p>在自定义构造函数时，原型对象默认只会获得<code>constructor</code>属性，其它所有方法都继承自Object。</p>\n<p>每次调用构造函数创建一个新实例，这个实例内部<code>[[Prototype]]</code>指针就会被赋值为构造函数的原型对象。</p>\n<p>脚本中没有访问这个<code>[[Prototype]]</code>特性的标准方式，但Firefox，Safari和Chrome会在每个对象上暴露<code>__proto__</code>属性，通过这个属性可以访问对象的原型。</p>\n<p><strong>关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//声明之后，构造函数就有了一个与之关联的原型对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> Person.prototype);<span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype);<span class=\"comment\">//打印出下面的原型对象</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\tconstructor: ƒ Person()</span></span><br><span class=\"line\"><span class=\"comment\">//\t__proto__: Object</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如前所述，构造函数有一个<code>prototype</code>属性引用其原型对象，而这个原型对象也有一个<code>constructor</code>属性引用这个构造函数；换句话说，<strong>两者互相引用</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.constructor === Person); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>正常的原型链都会<strong>终止于<code>Object</code>的原型对象</strong>，<code>Object</code>原型的原型是<code>null</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.__proto__.constructor === <span class=\"built_in\">Object</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.__proto__.__proto__ === <span class=\"literal\">null</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.__proto__);</span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     constructor: ƒ Object(),</span></span><br><span class=\"line\"><span class=\"comment\">//     hasOwnProperty: ƒ hasOwnProperty(),</span></span><br><span class=\"line\"><span class=\"comment\">//     isPrototypeOf: ƒ isPrototypeOf(),</span></span><br><span class=\"line\"><span class=\"comment\">//     propertyIsEnumerable: ƒ propertyIsEnumerable(),</span></span><br><span class=\"line\"><span class=\"comment\">//     toLocaleString: ƒ toLocaleString(),</span></span><br><span class=\"line\"><span class=\"comment\">//     toString: ƒ toString(),</span></span><br><span class=\"line\"><span class=\"comment\">//     valueOf: ƒ valueOf(),</span></span><br><span class=\"line\"><span class=\"comment\">//     __defineGetter__: ƒ __defineGetter__(),</span></span><br><span class=\"line\"><span class=\"comment\">//     __defineSetter__: ƒ __defineSetter__(),</span></span><br><span class=\"line\"><span class=\"comment\">//     __lookupGetter__: ƒ __lookupGetter__(),</span></span><br><span class=\"line\"><span class=\"comment\">//     __lookupSetter__: ƒ __lookupSetter__(),</span></span><br><span class=\"line\"><span class=\"comment\">//     get __proto__: ƒ __proto__(),</span></span><br><span class=\"line\"><span class=\"comment\">//     set __proto__: ƒ __proto__()</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>构造函数、原型对象和实例是3个完全不同的对象</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1 !== Person); <span class=\"comment\">//true，实例与构造函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1 !== Person.prototype); <span class=\"comment\">//true，实例与原型对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype !== Person); <span class=\"comment\">//true，原型对象与构造函数</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><strong>实例通过<code>__proto__</code>连接到原型对象，它实际指向<code>[[prototype]]</code></strong></p>\n</li>\n<li>\n<p><strong>构造函数通过<code>prototype</code>属性链接到原型对象</strong></p>\n</li>\n<li>\n<p><strong>实例与构造函数没有直接联系，与原型对象有直接联系</strong></p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.__proto__ === Person.prototype); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.__proto__.constructor === Person)l <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>同一个构造函数创建的两个实例共享一个原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.__proto__ === person2.__proto__); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>可以使用<code>instance</code>检查实例的原型链中是否包含指定构造函数的原型</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006SqI8Ply1gooj740jvmj30rx0g00sq.jpg\" alt=\"2021-03-19_003710.png\" class=\"φbs\"></p>\n","prev":{"title":"哈希集合（HashSet）","link":"2021/03/12/数据结构/哈希集合（HashSet）"},"next":{"title":"每日一题：LC200 岛屿数量","link":"2021/03/11/刷题日记/每日一题：LC200 岛屿数量"},"plink":"http://example.com/2021/03/11/JavaScript/8-2-创建对象/","toc":[{"id":"创建对象","title":"创建对象","index":"1","children":[{"id":"工厂模式","title":"工厂模式","index":"1.1"},{"id":"构造函数模式","title":"构造函数模式","index":"1.2","children":[{"id":"1.-构造函数也是函数","title":"1. 构造函数也是函数","index":"1.2.1"},{"id":"2.-构造函数的问题","title":"2. 构造函数的问题","index":"1.2.2"}]},{"id":"原型模式","title":"原型模式","index":"1.3","children":[{"id":"1.-理解原型","title":"1. 理解原型","index":"1.3.1"}]}]}]}