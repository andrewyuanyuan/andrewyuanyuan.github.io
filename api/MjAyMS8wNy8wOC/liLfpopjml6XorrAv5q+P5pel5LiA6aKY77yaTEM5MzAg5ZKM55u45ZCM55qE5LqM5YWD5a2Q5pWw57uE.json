{"title":"每日一题：LC930 和相同的二元子数组","date":"2021-07-07T16:00:00.000Z","date_formatted":{"ll":"Jul 8, 2021","L":"07/08/2021","MM-DD":"07-08"},"link":"2021/07/08/刷题日记/每日一题：LC930 和相同的二元子数组","tags":["LeetCode"],"categories":["LeetCode"],"updated":"2021-07-08T03:38:31.814Z","content":"<h1 id=\"每日一题：lc930-和相同的二元子数组\">每日一题：LC930 和相同的二元子数组<a title=\"#每日一题：lc930-和相同的二元子数组\" href=\"#每日一题：lc930-和相同的二元子数组\"></a></h1>\n<p><a href=\"https://leetcode-cn.com/problems/binary-subarrays-with-sum/\" target=\"_blank\">930. 和相同的二元子数组</a>-Medium</p>\n<p>本文内容来源：</p>\n<ol>\n<li><a href=\"https://leetcode-cn.com/problems/binary-subarrays-with-sum/solution/he-xiang-tong-de-er-yuan-zi-shu-zu-by-le-5caf/\" target=\"_blank\">LeetCode</a>官方解答</li>\n<li>作者 于<a href=\"https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/solution/430-dfsshi-xian-jian-dan-yi-li-jie-dai-z-n6dj/\" target=\"_blank\">Leetcode的回答</a></li>\n</ol>\n<hr>\n<h2 id=\"前缀和-+-哈希表\">前缀和 + 哈希表<a title=\"#前缀和-+-哈希表\" href=\"#前缀和-+-哈希表\"></a></h2>\n<p>假设原数组的前缀和数组为<code>sum</code>，子数组<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"4.346ex\" height=\"2.843ex\" style=\"vertical-align: -0.838ex;\" viewbox=\"0 -863.1 1871.2 1223.9\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">(i,j]</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMAIN-28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-69\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-2C\" d=\"M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6A\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-5D\" d=\"M22 710V750H159V-250H22V-210H119V710H22Z\"/>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMAIN-28\" x=\"0\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-69\" x=\"389\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMAIN-2C\" x=\"735\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-6A\" x=\"1180\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMAIN-5D\" x=\"1592\" y=\"0\"/>\n</g>\n</svg>的区间和为<code>goal</code>，那么<code>sum[j]-sum[i]=goal</code>。因此我们可以枚举<code>j</code>，每次查询满足该等式的<code>i</code>的数量。</p>\n<p>具体地，我们用哈希表记录每一种前缀和出现的次数，假设我们当前枚举到元素<code>nums[j]</code>，我们只需要查询哈希表中元素<code>sum[j]-goal</code>的数量即可，这些元素数量即对应了以当前<code>j</code>值为右边界的满足条件的子数组的数量（即<code>sum[i]</code>）。最后这些元素的总数量即为所有和为<code>goal</code>的子数组数量。</p>\n<p>在实际代码中，我们实时更新哈希表，放置出现<code>i≥j</code>的情况。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numSubarraysWithSum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, goal</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(num <span class=\"keyword\">of</span> nums)&#123;</span><br><span class=\"line\">        map.set(sum, (map.get(sum) || <span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">        sum += num;</span><br><span class=\"line\">        res += map.get(sum-goal) || <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：O(n)，其中n为给定数组的长度。对于数组中的每个元素，我们至多只需要插入到哈希表表中一次。</li>\n<li>空间复杂度：O(n)，其中n为给定数组的长度，哈希表中只存储n个元素。</li>\n</ul>\n<h2 id=\"滑动窗口\">滑动窗口<a title=\"#滑动窗口\" href=\"#滑动窗口\"></a></h2>\n<p>注意到对于方法一中每一个<code>j</code>，满足<code>sum[j]-sum[i]=goal</code>的<code>i</code>总落在一个连续的区间中，<code>i</code>值取区间中每一个数都满足条件。并且随着<code>j</code>右移，其对应的区间的左右端点也将右移，这样我们即可使用滑动窗口解决本题。</p>\n<p>具体地，我们令滑动窗口右边界为<code>right</code>，使用两个左边界<code>left1</code>和<code>left2</code>表示左区间，此时有<code>left2-left1</code>个区间满足条件。</p>\n<p>在实际代码中，我们需要注意<code>left1&lt;=left2&lt;=right+1</code>，因此需要在代码中限制<code>left1</code>和<code>left2</code>不超出范围。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numSubarraysWithSum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> goal)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left1 = <span class=\"number\">0</span>, left2 = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum1 = <span class=\"number\">0</span>, sum2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right&lt;n)&#123;</span><br><span class=\"line\">            sum1 += nums[right];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(left1 &lt;= right &amp;&amp; sum1 &gt; goal)&#123;</span><br><span class=\"line\">\t\t\t\tsum1 -= nums[left1];</span><br><span class=\"line\">                left1++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            sum2 += nums[right];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(left2 &lt;= right &amp;&amp; sum2 &gt;= goal)&#123;</span><br><span class=\"line\">                sum2-=nums[left2];</span><br><span class=\"line\">                left2++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            ret+=left2-left1;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：O(n)，其中n为给定数组的长度，我们至多只需要遍历一次该数组。</li>\n<li>空间复杂度：O(1)，我们只需要常数的空间保存若干变量。</li>\n</ul>\n","prev":{"title":"摩尔投票算法（Boyer-Moore）","link":"2021/07/09/算法/摩尔投票算法（Boyer-Moore）"},"next":{"title":"优先队列（Priority Queue）","link":"2021/07/08/数据结构/优先队列（Priority Queue）"},"plink":"http://example.com/2021/07/08/刷题日记/每日一题：LC930 和相同的二元子数组/","toc":[{"id":"每日一题：lc930-和相同的二元子数组","title":"每日一题：LC930 和相同的二元子数组","index":"1","children":[{"id":"前缀和-+-哈希表","title":"前缀和 + 哈希表","index":"1.1"},{"id":"滑动窗口","title":"滑动窗口","index":"1.2"}]}]}