{"title":"8.3 继承","date":"2021-03-21T16:00:00.000Z","date_formatted":{"ll":"Mar 22, 2021","L":"03/22/2021","MM-DD":"03-22"},"link":"2021/03/22/JavaScript/8-3-继承","tags":["JavaScript"],"categories":["JS Technique"],"updated":"2021-04-24T09:56:54.551Z","content":"<p>[TOC]</p>\n<p><strong>更新日志：</strong></p>\n<p>2021.3.22：P238-249，8.3</p>\n<h1 id=\"继承\">继承<a title=\"#继承\" href=\"#继承\"></a></h1>\n<p>很多面向对象语言都支持两种继承：接口继承与实现继承。前者只继承方法签名，后者继承实际的方法。接口集成在ECMAScript中是不可能的，因为函数没有签名。<strong>实现继承是ECMAScript唯一支持的继承方式，而这主要是通过原型链实现的。</strong></p>\n<h2 id=\"原型链\">原型链<a title=\"#原型链\" href=\"#原型链\"></a></h2>\n<p>ECMA-262 把原型链定义为 ECMAScript 的主要继承方式，其基本思想就是<strong>通过原型继承多个引用类型的属性和方法</strong>。重温一下构造函数、原型和实力的关系：</p>\n<p>如果原型是另一个类型的实例呢？</p>\n<p><strong>那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本思想。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.property;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//继承SuperType</span></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\">SubType.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.subproperty;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> instance = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance.getSuperValue());<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p><code>SubType</code>通过创建<code>SuperType</code>的实例并将其赋值给自己的原型<code>Subtype.prototype</code>实现了对<code>SuperType</code>的继承。这个赋值重写了<code>SubType</code>最初的原型，将其替换为<code>SuperType</code>的实例。</p>\n<p>这意味着<code>SuperType</code>实例可以访问的所有属性和方法也会存在于<code>SubType.prototype</code>。</p>\n<p>这样实现继承后，代码又紧接着又给<code>SubType.prototype</code>，也就是这个<code>SuperType</code>的实例添加了一个新方法。</p>\n<p>最后又创建了<code>SubType</code>的实例并调用了它继承的<code>getSuperValue()</code>方法。</p>\n<p><img src=\"https://raw.githubusercontent.com/andrewyuanyuan/blog-image/main/img/006SqI8Ply1gosjgv3y6fj30fr0970so.jpg\" alt=\"2021-03-22_114948.png\" class=\"φbs\"></p>\n<p>这个例子中实现继承的关键，**是<code>SubType</code>没有使用默认原型，而是将其替换成了一个新的对象。这个新的对象恰好是<code>SuperType</code>的实例。**这样一来，<code>SubType</code>的实例不仅能从<code>SuperType</code>的实例中继承属性和方法，而且还与<code>SuperType</code>的原型挂上了钩。</p>\n<p>于是<code>instance</code>（通过内部的<code>[[Prototype]]</code>）指向<code>SubType.prototype</code>，而<code>SubType.prototype</code>（作为<code>SuperType</code>的实例又通过内部的<code>[[Prototype]]</code>）指向<code>SuperType.prototype</code>。</p>\n<p>注意，<strong><code>getSuperValue()</code>方法还在<code>SuperType.prototype</code>对象上，而<code>property</code>属性则在<code>SubType.prototype</code>上</strong>。这是因为<code>getSuperValue()</code>方法是一个原型方法，而<code>property</code>是个实例属性。<code>SubType.prototype</code>现在是<code>SuperType</code>的一个实例，因此<code>property</code>才会存储在它上面。</p>\n<p>还要注意，由于<code>SubType.prototype</code>的<code>constructor</code>属性被重写为指向<code>SuperType</code>，所以<code>instance.constructor</code>也指向<code>SuperType</code>。</p>\n<hr>\n<p>**原型链扩展了前面描述的原型搜索机制。**我们知道，在读取实例上的属性时，首先会在实例上搜索这个属性。如果没有找到，则会继承搜索实例的原型。<strong>在通过原型链实现继承后，搜索就可以继承向上，搜索原型的原型</strong>。对上面的例子而言，调用<code>instance.getSuperValue()</code>经过了3个步骤：<code>instance</code>、<code>SubType.prototype</code>和<code>SuperType.prototype</code>，最后一步才找到这个方法。对属性和方法的搜索会一直持续到原型链末端。</p>\n<h3 id=\"1.-默认原型\">1. 默认原型<a title=\"#1.-默认原型\" href=\"#1.-默认原型\"></a></h3>\n<p>实际上，原型链中还有一环。默认情况下，<strong>所有引用类型都继承自<code>Object</code></strong>，这也是通过原型链实现的。<strong>任何函数的默认原型都是一个<code>Object</code>实例</strong>，这意味着这个实例有一个内部指针指向<code>Object.prototype</code>。这也是为什么自定义类型能够继承包括<code>toString()</code>，<code>valueOf()</code>在内的所有默认方法的原因。因此前面的例子还有一层额外的继承关系。如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/andrewyuanyuan/blog-image/main/img/006SqI8Ply1gosolwbuvtj30io0ju74h.jpg\" alt=\"2021-03-22_144727.png\" class=\"φbs\"></p>\n<p><code>SubType</code>继承<code>SuperType</code>，而<code>SuperType</code>继承<code>Object</code>，在调用<code>instance.toString()</code>时，实际上调用的是保存在<code>Object.prototype</code>上的方法。</p>\n<h3 id=\"2.-原型与继承关系\">2. 原型与继承关系<a title=\"#2.-原型与继承关系\" href=\"#2.-原型与继承关系\"></a></h3>\n<p>原型和实例的关系通过两种方式确定：</p>\n<ol>\n<li>\n<p>使用<code>instanceof</code>操作符</p>\n<p>如果一个实例的原型链中出现过相应的构造函数，则<code>instanceof</code>返回<code>true</code>。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(instance <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance <span class=\"keyword\">instanceof</span> SuperType);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance <span class=\"keyword\">instanceof</span> SubType);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>使用<code>isPrototypeOf()</code>方法</p>\n<p>原型链中的每个原型都可以调用这个方法，如下例所示，只要原型链中包含这个原型，就返回<code>true</code>。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.isPrototypeOf(instance));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(SuperType.prototype.isPrototypeOf(instance));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(SubType.prototype.isPrototypeOf(instance));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"3.-关于方法\">3. 关于方法<a title=\"#3.-关于方法\" href=\"#3.-关于方法\"></a></h3>\n<p>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值后再添加到原型上。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.property;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//继承SuperType</span></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//新方法</span></span><br><span class=\"line\">SubType.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.subproperty;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//覆盖已有方法</span></span><br><span class=\"line\">SubType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，<code>getSubValue()</code>是新增的方法，而<code>getSuperValue()</code>是原型链上已经存在但在这里被遮蔽的方法。后面在<code>SubType</code>实例上调用<code>getSuperValue()</code>时调用的是这个方法，但<code>SuperType</code>的实例仍然会调用最初的方法。<strong>重点在于上述两个方法都是在把原型赋值为<code>SuperType</code>的实例之后定义的。</strong></p>\n<p>另一个要理解的重点是：<strong>以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链</strong>。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.property;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//继承SuperType</span></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"><span class=\"comment\">//通过对象字面量添加新方法，这会导致上一行无效</span></span><br><span class=\"line\">SubType.prototype = &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getSubValue</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.subproperty;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">someOtherMethod</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> instance = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance.getSuperValue());<span class=\"comment\">//报错</span></span><br></pre></td></tr></table></figure>\n<p>**在这段代码中，子类的原型链在被赋值为<code>SuperType</code>的实例后，又被另一个对象字面量覆盖了。覆盖后的原型是一个<code>Object</code>的实例，而不再是<code>SuperType</code>的实例。**因此此前的原型链就断了，<code>SubType</code>和<code>SuperType</code>之间也没有关系了。</p>\n<h3 id=\"4.-原型链的问题\">4. 原型链的问题<a title=\"#4.-原型链的问题\" href=\"#4.-原型链的问题\"></a></h3>\n<p>原型链虽然是实现继承的强大工具，但是也存在着问题。</p>\n<ol>\n<li>\n<p><strong>原型包含的引用值会在所有实例间共享</strong>。</p>\n<p>这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承的时候，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.colors = [<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>, <span class=\"string\">&quot;green&quot;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">&quot;black&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors);<span class=\"comment\">//[ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> instance2 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.colors);<span class=\"comment\">//[ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span></span><br></pre></td></tr></table></figure>\n<p>当<code>SubType</code>通过原型链继承<code>SuperType</code>后，<code>SubType.prototype</code>变成了<code>SuperType</code>的一个实例，因而也获得了自己的<code>colors</code>属性。这类似于创建了<code>SubType.prototype.colors</code>属性。<strong>最终结果是，<code>SubType</code>的所有实例都会共享这个<code>colors</code>属性。这一点通过<code>instance1.colors</code>上的修改能反映到<code>instance2.colors</code>上就能看得出来。</strong></p>\n</li>\n<li>\n<p><strong>子类型在实例化时不能给父类型的构造函数传参。</strong></p>\n<p><strong>事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。</strong></p>\n<p>再加上之前提到过的原型中包含引用值的问题，<strong>就导致原型链基本不会被单独使用。</strong></p>\n</li>\n</ol>\n<h2 id=\"盗用构造函数\">盗用构造函数<a title=\"#盗用构造函数\" href=\"#盗用构造函数\"></a></h2>\n<p>为了解决原型包含引用值导致的继承问题，一种叫做“<strong>盗用构造函数</strong>“（constructor stealing）的技术在开发社区流行起来（这种技术有时候也称为”<strong>对象伪装</strong>“和“<strong>经典继承</strong>”）。</p>\n<p>基本思路为：<strong>在子类的构造函数中调用父类构造函数</strong>。因为<strong>毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用<code>apply()</code>和<code>call()</code>方法以新创建的对象为上下文执行构造函数</strong>。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.colors = [<span class=\"string\">&quot;red&quot;</span>,<span class=\"string\">&quot;blue&quot;</span>,<span class=\"string\">&quot;green&quot;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//继承SuperType</span></span><br><span class=\"line\">    SuperType.call(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">&quot;black&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors);<span class=\"comment\">//[ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> instance2 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.colors);<span class=\"comment\">//[ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span></span><br></pre></td></tr></table></figure>\n<p><code>SuperType.call(this)</code>展示了盗用构造函数的调用。<strong>通过使用<code>call()</code>（或<code>apply()</code>）方法，<code>SuperType</code>构造函数在为<code>SubType</code>的实例创建的新对象的上下文中执行了。这相当于新的<code>SubType</code>对象上运行了<code>SuperType()</code>函数中的所有初始化代码。结果就是每个实例都会有自己的<code>colors</code>属性。</strong></p>\n<h3 id=\"1.-传递参数\">1. 传递参数<a title=\"#1.-传递参数\" href=\"#1.-传递参数\"></a></h3>\n<p>相比于使用原型链，盗用构造函数的一个优点就是<strong>可以在子类构造函数中向父类构造函数传参</strong>。来看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//继承SuperType并传参</span></span><br><span class=\"line\">    SuperType.call(<span class=\"built_in\">this</span>, <span class=\"string\">&quot;Nicholas&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//实例属性</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> instance = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance.name);<span class=\"comment\">//Nicholas</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance.age);<span class=\"comment\">//29</span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，<code>SuperType</code>构造函数接收一个参数<code>name</code>，然后将它赋值给一个属性。在<code>SubType</code>构造函数中调用<code>SuperType</code>构造函数时传入这个参数，实际上会在<code>SubType</code>的实例上定义<code>name</code>属性。</p>\n<p>为确保<code>SuperType</code>构造函数不会覆盖<code>SubType</code>定义的属性，可以在调用父类构造函数之后再给子类实例添加额外的属性。</p>\n<h3 id=\"2.-盗用构造函数的问题\">2. 盗用构造函数的问题<a title=\"#2.-盗用构造函数的问题\" href=\"#2.-盗用构造函数的问题\"></a></h3>\n<p>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：</p>\n<ol>\n<li><strong>必须在构造函数中定义方法，因此函数不能重用。</strong></li>\n<li><strong>子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。</strong></li>\n</ol>\n<p>由于存在这些问题，盗用构造函数基本上也不能单独使用。</p>\n<h2 id=\"组合继承（伪经典继承）\">组合继承（伪经典继承）<a title=\"#组合继承（伪经典继承）\" href=\"#组合继承（伪经典继承）\"></a></h2>\n<p>组合继承综合了原型链和盗用构造函数，将两者的优势结合了起来。</p>\n<p>基本思路：<strong>使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性</strong>。</p>\n<p>这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.colors = [<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>, <span class=\"string\">&quot;green&quot;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//继承属性</span></span><br><span class=\"line\">    SuperType.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//继承方法</span></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><code>SuperType</code>构造函数定义了两个属性，<code>name</code>和<code>colors</code>，而它的原型上也定义了一个方法叫<code>sayName()</code>。</p>\n</li>\n<li>\n<p><code>SubType</code>构造函数调用了<code>SuperType</code>构造函数，传入了<code>name</code>参数，然后有又定义了自己的属性<code>age</code>。</p>\n</li>\n<li>\n<p>此外，<code>SubType.prototype</code>也被赋值为<code>SuperType</code>的实例。原型赋值之后，又在这个原型上添加了新方法<code>sayAge()</code>。</p>\n</li>\n<li>\n<p><code>SubType.prototype</code>成为了<code>SuperType</code>的一个新实例，因此<code>name</code>和<code>colors</code>这两个实例属性存储在了<code>SubType.prototype</code>上。如下所示：</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(SubType.prototype)</span><br><span class=\"line\"><span class=\"comment\">// SuperType &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    name: undefined,</span></span><br><span class=\"line\"><span class=\"comment\">//    colors: [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ],</span></span><br><span class=\"line\"><span class=\"comment\">//    sayAge: [Function]</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<p>这样，就可以创建两个<code>SubType</code>实例，让这两个实例都有自己的属性，包括<code>colors</code>，同时还共享相同的方法。</p>\n<p>组合继承弥补了原型链和盗用构造函数的不足，是JavaScript中使用最多的继承模式。而且组合继承也保留了<code>instanceof</code>操作符和<code>isPrototypeOf()</code>方法识别合成对象的能力。</p>\n<h2 id=\"原型式继承\">原型式继承<a title=\"#原型式继承\" href=\"#原型式继承\"></a></h2>\n<p>原型式继承是一种不涉及严格意义上构造函数的继承方法。出发点是**即使不自定义类型也可以 通过原型 实现 对象之间的信息共享。**模式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个<code>object()</code>函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，<code>object()</code>是对传入的对象执行了一次浅复制。来看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&quot;Nicholas&quot;</span>,</span><br><span class=\"line\">    friends: [<span class=\"string\">&quot;Shelby&quot;</span>, <span class=\"string\">&quot;Court&quot;</span>, <span class=\"string\">&quot;Van&quot;</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> anotherPerson = object(person);</span><br><span class=\"line\">anotherPerson.name = <span class=\"string\">&quot;Greg&quot;</span>;</span><br><span class=\"line\">anotherPerson.friends.push(<span class=\"string\">&quot;Rob&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> yetAnotherPerson = object(person);</span><br><span class=\"line\">yetAnotherPerson.name = <span class=\"string\">&quot;Linda&quot;</span>;</span><br><span class=\"line\">yetAnotherPerson.friends.push(<span class=\"string\">&quot;Barbie&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.friends);<span class=\"comment\">//[ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span></span><br></pre></td></tr></table></figure>\n<p>原型式继承适用于这种情况：**你有一个对象，想在它的基础上再创建一个新对象。**你需要先把这个对象传给<code>object()</code>，然后再对返回的对象进行适当修改。</p>\n<p>在这个例子中，<code>person</code>对象定义了另一个对象也应该共享的信息，把它传给<code>object()</code>之后会返回一个新对象。这个新对象的原型是<code>person</code>，**这意味着它的原型上既有原始值属性又有引用值属性。**这也意味着<code>person.friends</code>不仅是<code>person</code>的属性，也会跟<code>anotherPerson</code>和<code>yetAnotherPerson</code>共享。这里实际上克隆了两个person。</p>\n<h4 id=\"object.create()\">Object.create()<a title=\"#object.create()\" href=\"#object.create()\"></a></h4>\n<p>**ECMAScript 5通过增加<code>Object.create()</code>方法将原型式的概念规范化了。**这个方法接受两个参数：</p>\n<ul>\n<li>作为新对象原型的对象</li>\n<li>给新对象定义额外属性的对象（可选）</li>\n</ul>\n<p>在只有第一个参数的时候，<code>Object.create()</code>与这里的<code>object()</code>方法效果相同：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&quot;Nicholas&quot;</span>,</span><br><span class=\"line\">    friends: [<span class=\"string\">&quot;Shelby&quot;</span>, <span class=\"string\">&quot;Court&quot;</span>, <span class=\"string\">&quot;Van&quot;</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> anotherPerson = <span class=\"built_in\">Object</span>.create(person);</span><br><span class=\"line\">anotherPerson.name = <span class=\"string\">&quot;Greg&quot;</span>;</span><br><span class=\"line\">anotherPerson.friends.push(<span class=\"string\">&quot;Rob&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> yetAnotherPerson = <span class=\"built_in\">Object</span>.create(person);</span><br><span class=\"line\">yetAnotherPerson.name = <span class=\"string\">&quot;Linda&quot;</span>;</span><br><span class=\"line\">yetAnotherPerson.friends.push(<span class=\"string\">&quot;Barbie&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.friends);<span class=\"comment\">//[ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.create()</code>的第二个参数与<code>Object.defineProperties()</code>的第二个参数一样：每个新增属性都通过各自的描述符来描述。<strong>以这种方式添加的属性会遮蔽原型对象上的同名属性</strong>。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&quot;Nicholas&quot;</span>,</span><br><span class=\"line\">    friends: [<span class=\"string\">&quot;Shelby&quot;</span>, <span class=\"string\">&quot;Court&quot;</span>, <span class=\"string\">&quot;Van&quot;</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> anotherPerson = <span class=\"built_in\">Object</span>.create(person, &#123;</span><br><span class=\"line\">    name:&#123;</span><br><span class=\"line\">        value: <span class=\"string\">&quot;Greg&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(anotherPerson.name);<span class=\"comment\">//Greg</span></span><br></pre></td></tr></table></figure>\n<p><strong>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象之间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象之间共享，跟使用原型模式是一样的。</strong></p>\n<h2 id=\"寄生式继承\">寄生式继承<a title=\"#寄生式继承\" href=\"#寄生式继承\"></a></h2>\n<p>与原型式继承比较接近的一种继承方式是<strong>寄生式继承</strong>。寄生式继承背后的思路类似于寄生构造函数和工厂模式：**创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。**基本的寄生继承模式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnother</span>(<span class=\"params\">original</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> clone = object(original); <span class=\"comment\">//通过调用函数创建一个新对象</span></span><br><span class=\"line\">    clone.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;     <span class=\"comment\">//以某种方式增强这个对象</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;hi&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clone;\t\t\t\t  <span class=\"comment\">//返回这个对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>createAnother()</code>函数接收一个参数，就是新对象的基准对象。这个对象<code>original</code>会被传给<code>object()</code>函数，然后将返回的新对象赋值给<code>clone</code>。接着给<code>clone</code>对象添加一个新方法<code>sayHi()</code>。最后返回这个对象。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&quot;Nicholas&quot;</span>,</span><br><span class=\"line\">    friends: [<span class=\"string\">&quot;Shelby&quot;</span>, <span class=\"string\">&quot;Court&quot;</span>, <span class=\"string\">&quot;Van&quot;</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> anotherPerson = createAnother(person);</span><br><span class=\"line\">anotherPerson.sayHi();<span class=\"comment\">//hi</span></span><br></pre></td></tr></table></figure>\n<p><strong>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景</strong>。<code>object()</code>函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。<strong>注意：通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</strong></p>\n<h2 id=\"寄生式组合继承\">寄生式组合继承<a title=\"#寄生式组合继承\" href=\"#寄生式组合继承\"></a></h2>\n<p>组合继承也存在效率问题：<strong>最主要的效率问题是父类构造函数始终会被调用两次，一次是在创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要执行时重写自己的原型就好了</strong>。再来看一看这个组合继承的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.colors = [<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>, <span class=\"string\">&quot;green&quot;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">    SuperType.call(<span class=\"built_in\">this</span>, name); <span class=\"comment\">//第二次调用SuperType()</span></span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.age = age;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType(); <span class=\"comment\">//第一次调用SuperType()</span></span><br><span class=\"line\">SubType.prototype.constructor = SubType;</span><br><span class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/andrewyuanyuan/blog-image/main/img/006SqI8Ply1got15y2dbxj30ha0dct8p.jpg\" alt=\"2021-03-22_220143.png\" class=\"φbs\"></p>\n<p>第一次调用<code>SuperType()</code>的时候，<code>SubType.prototype</code>上会有两个属性：<code>name</code>和<code>colors</code>。它们都是<code>SuperType</code>的实例属性，但现在成为了<code>SubType</code>的原型属性。如上图所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/andrewyuanyuan/blog-image/main/img/006SqI8Ply1got162aavcj30h80cjjrd.jpg\" alt=\"2021-03-22_220154.png\" class=\"φbs\"></p>\n<p>在调用<code>SubType</code>构造函数时，第二次调用<code>SuperType()</code>，这一次会在新对象上创建实例属性<code>name</code>和<code>colors</code>。这两个实例属性会遮蔽原型上同名的属性。如上图所示。</p>\n<p><strong>在上面的组合继承中，有两组<code>name</code>和<code>colors</code>属性，实际上只需要一组，如何解决呢？</strong></p>\n<p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方式。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。**说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。**基本模式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">subType, superType</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> prototype = object(superType.prototype);<span class=\"comment\">//创建对象</span></span><br><span class=\"line\">    prototype.constructor = subType;\t\t\t<span class=\"comment\">//增强对象</span></span><br><span class=\"line\">    subType.prototype = prototype;\t\t\t\t<span class=\"comment\">//赋值对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数接收两个参数：子类构造函数和父类构造函数。在函数内部：</p>\n<ol>\n<li>创建父类原型的一个副本</li>\n<li>给返回的<code>prototype</code>对象设置<code>constructor</code>属性，解决由于重写原型导致默认<code>constructor</code>丢失的问题</li>\n<li>最后将新创建的对象赋值给子类型的原型</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.colors = [<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>, <span class=\"string\">&quot;green&quot;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">    SuperType.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inheritPrototype(SubType, SuperType);</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(SubType.prototype);</span><br><span class=\"line\"><span class=\"comment\">//SubType &#123; constructor: [Function: SubType], sayAge: [Function] &#125;</span></span><br></pre></td></tr></table></figure>\n<p>这里只调用了一次<code>SuperType</code>构造函数，避免了<code>SubType.prototype</code>上不必要也用不到的属性，因此可以说这个例子的效率更高。而且，原型链仍然保持不变，因此<code>instanceof</code>操作符和<code>isPrototypeOf()</code>方法正常有效。<strong>寄生式组合继承可以算是引用类型继承的最佳模式。</strong></p>\n","prev":{"title":"每日一题：LC494 目标和（待补充）","link":"2021/03/23/刷题日记/每日一题：LC494 目标和（待补充）"},"next":{"title":"每日一题：LC394 字符串解码","link":"2021/03/17/刷题日记/每日一题：LC394 字符串解码"},"plink":"http://example.com/2021/03/22/JavaScript/8-3-继承/","toc":[{"id":"继承","title":"继承","index":"1","children":[{"id":"原型链","title":"原型链","index":"1.1","children":[{"id":"1.-默认原型","title":"1. 默认原型","index":"1.1.1"},{"id":"2.-原型与继承关系","title":"2. 原型与继承关系","index":"1.1.2"},{"id":"3.-关于方法","title":"3. 关于方法","index":"1.1.3"},{"id":"4.-原型链的问题","title":"4. 原型链的问题","index":"1.1.4"}]},{"id":"盗用构造函数","title":"盗用构造函数","index":"1.2","children":[{"id":"1.-传递参数","title":"1. 传递参数","index":"1.2.1"},{"id":"2.-盗用构造函数的问题","title":"2. 盗用构造函数的问题","index":"1.2.2"}]},{"id":"组合继承（伪经典继承）","title":"组合继承（伪经典继承）","index":"1.3"},{"id":"原型式继承","title":"原型式继承","index":"1.4"},{"id":"寄生式继承","title":"寄生式继承","index":"1.5"},{"id":"寄生式组合继承","title":"寄生式组合继承","index":"1.6"}]}]}