{"title":"二叉树（Binary Tree）","date":"2021-03-31T16:00:00.000Z","date_formatted":{"ll":"Apr 1, 2021","L":"04/01/2021","MM-DD":"04-01"},"link":"2021/04/01/数据结构/二叉树（Binary Tree）","categories":["Data Structure"],"updated":"2021-04-02T07:58:30.200Z","content":"<p>[TOC]</p>\n<h1 id=\"二叉树（binary-tree）（待补充）\">二叉树（Binary Tree）（待补充）<a title=\"#二叉树（binary-tree）（待补充）\" href=\"#二叉树（binary-tree）（待补充）\"></a></h1>\n<h2 id=\"树的遍历\">树的遍历<a title=\"#树的遍历\" href=\"#树的遍历\"></a></h2>\n<p>数的遍历包括：</p>\n<ul>\n<li>\n<p>前序遍历：根左右</p>\n</li>\n<li>\n<p>中序遍历：左根右</p>\n<p>通常来说，我们可以通过中序遍历得到一个递增的有序序列</p>\n</li>\n<li>\n<p>后序遍历：左右根</p>\n<p>删除树中的节点，删除过程将按照后序遍历的顺序进行。也就是说，删除的时候会先删除它的左节点和右节点，然后删除节点本身。</p>\n<p>此外，后序在数学表达式中被广泛使用，编写程序解析后缀表示法更为容易。</p>\n</li>\n</ul>\n<h3 id=\"使用递归方法来遍历树\">使用递归方法来遍历树<a title=\"#使用递归方法来遍历树\" href=\"#使用递归方法来遍历树\"></a></h3>\n<p>前序遍历：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrderRecur</span><span class=\"params\">(TreeNode head)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.print(head.value + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">    preOrderRecur(head.left);</span><br><span class=\"line\">    preOrderRecur(head.right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中序和后序仅需要调整<code>System.out.print(head.value)</code>至中间和最后即可。</p>\n<h3 id=\"迭代解法\">迭代解法<a title=\"#迭代解法\" href=\"#迭代解法\"></a></h3>\n<p>本质上是在模拟递归，在迭代的方法中我们使用<code>stack</code>来模拟系统栈。</p>\n<p>前序遍历：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrderIteration</span><span class=\"params\">(TreeNode head)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(head==<span class=\"keyword\">null</span>)\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    stack.push(head);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!stack.isEmpty())&#123;</span><br><span class=\"line\">\t\tTreeNode node = stack.pop();</span><br><span class=\"line\">        System.out.print(node.value + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.right != <span class=\"keyword\">null</span>)\tstack.push(node.right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.left != <span class=\"keyword\">null</span>)\tstack.push(node.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中序遍历：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrderIteration</span><span class=\"params\">(TreeNode head)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>) \t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    TreeNode cur = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!stack.isEmpty())&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(cur!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tstack.push(cur);</span><br><span class=\"line\">            cur = cur.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode node = stack.pop();</span><br><span class=\"line\">        System.out.print(node.value + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.right!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            cur = node.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后序遍历：</p>\n<ol>\n<li>\n<p>前序遍历的过程是 根左右</p>\n</li>\n<li>\n<p>将其转化为 中右左。也就是压栈的时候先压入左子树，在押入右子树。</p>\n</li>\n<li>\n<p>然后将这个结果返回来，这里是利用栈的先进后出倒序打印。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"keyword\">null</span>)  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack1 = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack2 = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        stack1.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack1.isEmpty())&#123;</span><br><span class=\"line\">            TreeNode node = stack1.pop();</span><br><span class=\"line\">            stack2.push(node);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.left!=<span class=\"keyword\">null</span>)\t\tstack1.push(node.left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.right!=<span class=\"keyword\">null</span>)\tstack1.push(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack2.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = stack2.pop().val;</span><br><span class=\"line\">            res.add(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","prev":{"title":"每日一题：LC42 接雨水","link":"2021/04/02/刷题日记/每日一题：LC42 接雨水"},"next":{"title":"回溯算法（Backtracking Algorithm）","link":"2021/03/31/算法/回溯算法（Backtracking Algorithm）"},"plink":"http://example.com/2021/04/01/数据结构/二叉树（Binary Tree）/","toc":[{"id":"二叉树（binary-tree）（待补充）","title":"二叉树（Binary Tree）（待补充）","index":"1","children":[{"id":"树的遍历","title":"树的遍历","index":"1.1","children":[{"id":"使用递归方法来遍历树","title":"使用递归方法来遍历树","index":"1.1.1"},{"id":"迭代解法","title":"迭代解法","index":"1.1.2"}]}]}]}