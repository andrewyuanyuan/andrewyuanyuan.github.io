{"title":"二分查找（Binary Search）","date":"2021-03-09T16:00:00.000Z","date_formatted":{"ll":"Mar 10, 2021","L":"03/10/2021","MM-DD":"03-10"},"link":"2021/03/10/算法/二分查找（Binary Search）","categories":["Algorithm"],"updated":"2021-07-16T05:51:07.077Z","content":"<p>[TOC]</p>\n<h1 id=\"二分查找\">二分查找<a title=\"#二分查找\" href=\"#二分查找\"></a></h1>\n<p><img src=\"https://cdn.jsdelivr.net/gh/andrewyuanyuan/blog-image/img/006SqI8Pgy1goftath3qvj31db0hoq5i.jpg\" alt=\"pic1\" class=\"φbs\"></p>\n<p>来自<code>yuan-chu-de-suan-fa-xiao-wu</code>于[leetcode的回答]</p>\n<h2 id=\"模板\">模板<a title=\"#模板\" href=\"#模板\"></a></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = ...;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(...)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//Java中的/向下取整</span></span><br><span class=\"line\">        <span class=\"comment\">//这样子写mid相比(right+left)/2可以防止因left和right的和太大导致的溢出，</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = left+(right-left)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid]===target)&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid&lt;target])&#123;</span><br><span class=\"line\">            left = ...</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid]&gt;target)&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ...;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二分查找中：不要出现<code>else</code>，而是把所有情况都用<code>else if</code>写清楚，这样可以清楚地展现所有细节。</p>\n<p>上面模板中<code>...</code>的地方，就是可能出现细节问题的地方，而编写二分查找的代码时，应该首先注意这些地方。</p>\n<h2 id=\"寻找一个数\">寻找一个数<a title=\"#寻找一个数\" href=\"#寻找一个数\"></a></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left&lt;=right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = left+(right-left)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid]==target)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid]&lt;target)&#123;</span><br><span class=\"line\">            left = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid]&gt;target)&#123;</span><br><span class=\"line\">            right = mid-<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>\n<p><strong>关于<code>while</code>循环中的符号，为什么是<code>&lt;=</code>，而不是<code>&lt;</code>？</strong></p>\n<p>当<code>right</code>的赋值是<code>nums.length-1</code>时，每次进行搜索的区间是[left, right]</p>\n<p>当<code>right</code>的赋值是<code>nums.length</code>时，每次进行搜索的区间是[left, right)</p>\n</li>\n<li>\n<p><strong><code>while</code>循环什么时候终止？</strong></p>\n<ul>\n<li>\n<p>当判断条件是<code>while(left&lt;=right)</code>时，循环的终止条件是<code>left == right+1</code>，写成区间的形式就是<code>[right+1, right]</code>此时区间为空，如<code>[3,2]</code>。</p>\n</li>\n<li>\n<p>当判断条件是<code>while(left&lt;right)</code>时，循环的终止条件是<code>left == right</code>，写成区间的形式就是<code>[left, right]</code>此时区间为空，如<code>[2,2]</code>，此时区间非空，还有一个数<code>2</code>，但此时<code>while</code>循环终止了，也就是说区间<code>[2,2]</code>被漏掉了，索引<code>2</code>并没有被搜索，这时候直接返回<code>-1</code>就是错误的。</p>\n<p>如果还是要使用<code>left&lt;right</code>的判断条件，则需要添加一个额外的判断语句：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(left&lt;right)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> nums[left]==target ? left : -<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>为什么是<code>left = mid + 1;</code>和<code>right = mid - 1</code>?</strong></p>\n<p>应为刚刚明确了每一次执行搜索的范围是<code>[left, right]</code>，<code>mid</code>已经被搜索过了，所以应该从该搜索区间去掉。</p>\n</li>\n</ol>\n<h2 id=\"寻找左侧边界的二分搜索\">寻找左侧边界的二分搜索<a title=\"#寻找左侧边界的二分搜索\" href=\"#寻找左侧边界的二分搜索\"></a></h2>\n<p><strong>以下是最常见的代码形式：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> left_count = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, target</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums.length==<span class=\"number\">0</span>)\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = nums.length; </span><br><span class=\"line\">    <span class=\"comment\">//注意：如果这里的right是nums.length，那么前面就要加上当nums.length==0时的额外判断</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left&lt;right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor(left+(right-left)/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid]==target)&#123;</span><br><span class=\"line\">            right = mid;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid]&gt;target)&#123;</span><br><span class=\"line\">            right = mid;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid]&lt;target)&#123;</span><br><span class=\"line\">            left= mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始右边界：nums.length</p>\n<p>搜索区间：[left, right)，初始：[0, nums.length)</p>\n<p>终止条件：left == right</p>\n<p>左区间更新：left  = mid+1，下一次搜索的是右区间，[mid+1, right)</p>\n<p>右区间更新：right = mid，下一次搜索的是左区间，[left, mid)</p>\n<ol>\n<li>\n<p><strong>我们寻找的这个【左侧边界】有什么特殊含义？</strong></p>\n<p>以下面的数组为例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nums = [<span class=\"number\">15</span>, <span class=\"number\">25</span>, <span class=\"number\">38</span>, <span class=\"number\">45</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">55</span>, <span class=\"number\">62</span>, <span class=\"number\">73</span>]</span><br><span class=\"line\"><span class=\"comment\">//          0   1   2   3   4   5   6   7   8</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryLeftBoundSearch(nums, <span class=\"number\">10</span>))  <span class=\"comment\">//0 ，意味着&lt;10的元素有0个</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryLeftBoundSearch(nums, <span class=\"number\">18</span>))  <span class=\"comment\">//1 ，意味着&lt;18的元素有1个</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryLeftBoundSearch(nums, <span class=\"number\">25</span>))  <span class=\"comment\">//1 ，意味着&lt;25的元素有1个</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryLeftBoundSearch(nums, <span class=\"number\">26</span>))  <span class=\"comment\">//2 ，意味着&lt;26的元素有2个</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryLeftBoundSearch(nums, <span class=\"number\">46</span>))  <span class=\"comment\">//4 ，意味着&lt;46的元素有4个</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryLeftBoundSearch(nums, <span class=\"number\">57</span>))  <span class=\"comment\">//7 ，意味着&lt;57的元素有7个</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryLeftBoundSearch(nums, <span class=\"number\">64</span>))  <span class=\"comment\">//8 ，意味着&lt;64的元素有8个</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryLeftBoundSearch(nums, <span class=\"number\">80</span>))  <span class=\"comment\">//9 ，意味着&lt;80的元素有9个</span></span><br></pre></td></tr></table></figure>\n<p>该函数的返回值为<code>[0, nums.length]</code></p>\n<ul>\n<li>\n<p>如果希望得到小于等于<code>target</code>的左边界的下标，需要在<code>return l</code>前加上：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l = l==<span class=\"number\">0</span> ? <span class=\"number\">0</span> : l-<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果想要的到制定<code>target</code>的最左边的元素，如果target不存在则返回<code>-1</code>，则需要加上如下判断语句：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(left==nums.length)\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> nums[left] == target ? left : -<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>为什么这个算法能够搜索左侧边界？</strong></p>\n<p>关键在于当<code>nums[mid]==target</code>时的处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(nums[mid]==target)\tright = mid;</span><br></pre></td></tr></table></figure>\n<p>在找到<code>target</code>时不要立即返回，而是缩小【搜索区间】的上界<code>right</code>，在区间<code>[left, mid)</code>中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p>\n</li>\n<li>\n<p><strong>如果我希望我的<code>right = nums.length-1</code>，应该怎么写？</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> left_count = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, target</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = nums.length-<span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left&lt;=right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor(left+(right-left)/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid]&lt;target)&#123;</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检查出界情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left &gt;= nums.length || nums[left]!=target)\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始右边界：nums.length-1</p>\n<p>搜索区间：[left, right]</p>\n<p>终止条件：left == right+1</p>\n<p>左区间更新：left  = mid+1，下一次搜索的是右区间，[mid+1, right]</p>\n<p>右区间更新：right = mid-1，下一次搜索的是左区间，[left, mid-1]</p>\n</li>\n</ol>\n<h2 id=\"寻找右侧边界的二分查找\">寻找右侧边界的二分查找<a title=\"#寻找右侧边界的二分查找\" href=\"#寻找右侧边界的二分查找\"></a></h2>\n<p>常见代码形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> right_bound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, target</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums.length==<span class=\"number\">0</span>)\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>, right = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &lt; right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> mid = l+r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid]&lt;=target)&#123;</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid]&gt;target)&#123;</span><br><span class=\"line\">            right = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>\n<p><strong>为什么使用这个算法可以找到右边界？</strong></p>\n<p>关键在于找到<code>target</code>时不要立即返回，而是缩小【搜索区间】的下界<code>left</code>，即不断向右收缩，达到锁定左侧边界的目的。</p>\n</li>\n<li>\n<p><strong>为什么最后返回的是<code>left-1</code>？</strong></p>\n<p>这是因为我们对<code>left</code>的更新必须是<code>left = mid+1</code>，也就是说<code>while</code>循环结束时，<code>nums[left]</code>一定不等于<code>target</code>了，而<code>nums[left-1]</code>可能是<code>target</code>。</p>\n</li>\n<li>\n<p><strong>如果<code>nums</code>中不存在<code>target</code>这个值怎么办？</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nums = [<span class=\"number\">15</span>, <span class=\"number\">25</span>, <span class=\"number\">38</span>, <span class=\"number\">45</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">55</span>, <span class=\"number\">62</span>, <span class=\"number\">73</span>]</span><br><span class=\"line\"><span class=\"comment\">//          0   1   2   3   4   5   6   7   8</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryRightBoundSearch(nums, <span class=\"number\">10</span>))  <span class=\"comment\">//-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryRightBoundSearch(nums, <span class=\"number\">18</span>))  <span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryRightBoundSearch(nums, <span class=\"number\">26</span>))  <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryRightBoundSearch(nums, <span class=\"number\">46</span>))  <span class=\"comment\">//3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryRightBoundSearch(nums, <span class=\"number\">57</span>))  <span class=\"comment\">//6</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryRightBoundSearch(nums, <span class=\"number\">64</span>))  <span class=\"comment\">//7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryRightBoundSearch(nums, <span class=\"number\">80</span>))  <span class=\"comment\">//8</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryRightBoundSearch(nums, <span class=\"number\">100</span>)) <span class=\"comment\">//8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binaryRightBoundSearch(nums, <span class=\"number\">47</span>))  <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n<p>对于右边界二分搜索算法，分一下情况讨论：</p>\n<ul>\n<li>如果<code>target</code>等于<code>nums</code>中的元素：<code>left-1</code>返回元素下标（如果有多个目标元素则返回最右边的元素的下标）</li>\n<li>如果<code>nums</code>中没有<code>target</code>元素：\n<ul>\n<li>如果<code>target</code>小于<code>nums</code>中最小元素：<code>left-1</code>返回<code>-1</code></li>\n<li>如果<code>target</code>大于<code>nums</code>中最大元素：<code>left-1</code>返回<code>nums.length-1</code></li>\n<li>如果<code>target</code>介于<code>nums</code>中元素中间：<code>left-1</code>返回左边界</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>如果想把右边界搜索算法也统一成两端都闭的形式应该怎么写？</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">right_bound</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里改成收缩左侧边界即可</span></span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这里改为检查 right 越界的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right &lt; <span class=\"number\">0</span> || nums[right] != target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"关于二分的本质\">关于二分的本质<a title=\"#关于二分的本质\" href=\"#关于二分的本质\"></a></h2>\n<p><a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/gong-shui-san-xie-yan-ge-olognyi-qi-kan-6d969/\" target=\"_blank\">153. 寻找旋转排序数组中的最小值</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/\" target=\"_blank\">154. 寻找旋转排序数组中的最小值 II</a></p>\n<p><img src=\"https://pic.leetcode-cn.com/1617852745-LoBNPK-image.png\" alt=\"image.png\" class=\"φbs\"></p>\n<p>图源：<a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-yuan-7xbty/\" target=\"_blank\">AC_OIer于LeetCode 154题的解答</a></p>\n<p>“二分的本质是**【两段性】**，并非单调性。<strong>只要一段满足某个性质，另一端不满足某个性质，就可以使用二分。</strong>” — from <a href=\"https://leetcode-cn.com/u/ac_oier/\" target=\"_blank\">宫水三叶L6</a></p>\n","prev":{"title":"每日一题：LC153 寻找旋转数组中的最小值","link":"2021/03/10/刷题日记/每日一题：LC153 寻找旋转数组中的最小值"},"next":{"title":"广度优先搜索（BFS）","link":"2021/03/10/算法/深度优先搜索与广度优先搜索（BFS & DFS）"},"plink":"http://example.com/2021/03/10/算法/二分查找（Binary Search）/","toc":[{"id":"二分查找","title":"二分查找","index":"1","children":[{"id":"模板","title":"模板","index":"1.1"},{"id":"寻找一个数","title":"寻找一个数","index":"1.2"},{"id":"寻找左侧边界的二分搜索","title":"寻找左侧边界的二分搜索","index":"1.3"},{"id":"寻找右侧边界的二分查找","title":"寻找右侧边界的二分查找","index":"1.4"},{"id":"关于二分的本质","title":"关于二分的本质","index":"1.5"}]}]}