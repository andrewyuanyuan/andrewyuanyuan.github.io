{"title":"摩尔投票算法（Boyer-Moore）","date":"2021-07-08T16:00:00.000Z","date_formatted":{"ll":"Jul 9, 2021","L":"07/09/2021","MM-DD":"07-09"},"link":"2021/07/09/算法/摩尔投票算法（Boyer-Moore）","categories":["Algorithm"],"updated":"2021-07-09T06:28:31.904Z","content":"<h1 id=\"摩尔投票算法（boyer-moore））\">摩尔投票算法（Boyer-Moore））<a title=\"#摩尔投票算法（boyer-moore））\" href=\"#摩尔投票算法（boyer-moore））\"></a></h1>\n<p>本文内容来源：</p>\n<ol>\n<li><a href=\"https://leetcode-cn.com/problems/find-majority-element-lcci/solution/zhu-yao-yuan-su-by-leetcode-solution-xr1p/\" target=\"_blank\">LeetCode</a>官方题解</li>\n</ol>\n<hr>\n<p>典例：<a href=\"https://leetcode-cn.com/problems/find-majority-element-lcci/\" target=\"_blank\">面试题 17.10. 主要元素</a>-Easy</p>\n<p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(1)</p>\n<p>基本思想：在每一轮投票中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等。</p>\n<p>主要元素定义：数组中占比超过一半的元素称之为主要元素。</p>\n<p>具体算法步骤如下：</p>\n<ol>\n<li>\n<p>维护一个候选主要元素<code>candidate</code>和候选主要元素的出现次数<code>count</code>，初始时<code>candidate</code>为任意值，<code>count=0</code>。</p>\n</li>\n<li>\n<p>遍历数组<code>nums</code>中的所有元素，遍历到元素<code>x</code>时，进行如下操作。</p>\n<ul>\n<li>如果<code>count=0</code>，则将<code>x</code>的值赋给<code>candidate</code>，否则不更新<code>candidate</code>的值；</li>\n<li>如果<code>x = candidate</code>，则将<code>count</code>加<code>1</code>，否则将<code>count</code>减<code>1</code>。</li>\n</ul>\n</li>\n<li>\n<p>遍历结束后，如果数组<code>nums</code>中存在主要元素，则<code>candidate</code>即为主要元素，否则<code>candidate</code>可能为数组中的任意一个元素。</p>\n</li>\n<li>\n<p>至此，我们得到了一个<strong>可能的</strong>主要元素，之所以只是<strong>可能的</strong>主要元素，是因为我们在处理过程中只使用了<code>candidate</code>和<code>count</code>来记录，我们无法确定最后剩下的<code>candidate</code>是经过多次抵消剩余的主要元素，还是只是不存在主要元素的数组中的无效随机元素。</p>\n<p>因此我们需要再进行一次遍历，检查<strong>可能的</strong>主要元素<code>x</code>的出现次数是否超过总数的一半。</p>\n</li>\n</ol>\n<hr>\n<p><strong>为什么当数组中存在主要元素时，Boyer-Moore投票算法可以确保得到主要元素？</strong></p>\n<p>在Boyer-Moore投票算法中，遇到相同的数将<code>count+1</code>，遇到不同的数字则将<code>count-1</code>。根据主要元素的定义，主要元素的出现次数大于其它元素的出现次数之和，因此在遍历过程中，主要元素和其它元素两两抵消，最后一定剩下至少一个主要元素，此时<code>candidate</code>为主要元素，且<code>count&gt;=1</code>。</p>\n<hr>\n<p><strong>代码实现：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> majorityElement = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = <span class=\"number\">1</span>, candidate = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count==<span class=\"number\">0</span>)    candidate = nums[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[i]==candidate)  count++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> count--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(num <span class=\"keyword\">of</span> nums)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num==candidate)  count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count&gt;nums.length/<span class=\"number\">2</span> ? candidate : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","prev":{"title":"每日一题：LC652 寻找重复的子树","link":"2021/07/09/刷题日记/每日一题：LC652 寻找重复的子树"},"next":{"title":"每日一题：LC930 和相同的二元子数组","link":"2021/07/08/刷题日记/每日一题：LC930 和相同的二元子数组"},"plink":"http://example.com/2021/07/09/算法/摩尔投票算法（Boyer-Moore）/","toc":[{"id":"摩尔投票算法（boyer-moore））","title":"摩尔投票算法（Boyer-Moore））","index":"1"}]}