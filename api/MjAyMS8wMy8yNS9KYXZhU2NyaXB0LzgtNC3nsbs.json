{"title":"8.4 类","date":"2021-03-24T16:00:00.000Z","date_formatted":{"ll":"Mar 25, 2021","L":"03/25/2021","MM-DD":"03-25"},"link":"2021/03/25/JavaScript/8-4-类","tags":["JavaScript"],"categories":["JS Technique"],"updated":"2021-03-28T14:19:32.368Z","content":"<p><strong>更新日志：</strong></p>\n<p>2021.3.28：完</p>\n<h1 id=\"类\">类<a title=\"#类\" href=\"#类\"></a></h1>\n<p>前面聊的都是如何只使用ECMAScript 5特性来模拟类似于类（class-like）的行为。不难看出，各种策略都有自己的问题和妥协。</p>\n<p><strong>ECMAScript 6新引入的<code>class</code>关键字具有正式定义类的能力。</strong><code>class</code>是ECMAScript中新的基础性语法糖结构，因此刚开始接触时可能会不太习惯。<strong>虽然ECMAScript 6类表面上看起来可以支持正式的面向对象编程，但实际上它使用的仍然是原型和构造函数的概念。</strong></p>\n<h2 id=\"类声明\">类声明<a title=\"#类声明\" href=\"#类声明\"></a></h2>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类声明</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//类表达式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Animal = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>和函数表达式类似，<strong>类表达式</strong>在它们被求值前也不能引用。</p>\n<p>不过，与函数定义不同的是，虽然函数声明可以提升，但类定义不能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数声明可以提升</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(FunctionDeclaration); <span class=\"comment\">// FunctionDeclaration() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FunctionDeclaration</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(FunctionDeclaration); <span class=\"comment\">// FunctionDeclaration() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//函数表达式不能被提升</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(FunctionDeclaration); <span class=\"comment\">// FunctionDeclaration() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> FunctionDeclaration = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(FunctionDeclaration); <span class=\"comment\">// FunctionDeclaration() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//类的声明和表达式均不能被提升</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ClassExpression); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ClassExpression = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ClassExpression); <span class=\"comment\">// class &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ClassDeclaration); <span class=\"comment\">// ReferenceError: ClassDeclaration is not defined</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassDeclaration</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ClassDeclaration); <span class=\"comment\">// class ClassDeclaration &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>另一个跟函数声明不同的地方是：函数受函数作用域限制，而类受块作用域限制。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FunctionDeclaration</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassDeclaration</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(FunctionDeclaration); <span class=\"comment\">//FunctionDeclaration</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ClassDeclaration); \t  <span class=\"comment\">//ReferenceError: ClassDeclaration is not defined</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类的构成\">类的构成<a title=\"#类的构成\" href=\"#类的构成\"></a></h3>\n<p><strong>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的</strong>。默认情况下，类定义中的代码都在<strong>严格模式</strong>下执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>()</span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;&#125;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title\">myFoo</span>()&#123;&#125;<span class=\"comment\">//获取函数</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">yourFoor</span>(<span class=\"params\"></span>)</span>&#123;&#125;<span class=\"comment\">//静态方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>类名的首字母要大写</strong>，以区别通过它创建的实例。</p>\n<p><strong>类表达式的名称是可选的</strong>。在把类表达式赋给变量后，可以通过<code>name</code>属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//class后面的PersonName是可选的，成为类表达式的名称</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> Person = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonName</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">identify</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(Person.name, PersonName.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p.identify();<span class=\"comment\">//PersonName, PersonName</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.name);<span class=\"comment\">//PersonName</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(PersonName);<span class=\"comment\">//ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"类构造函数\">类构造函数<a title=\"#类构造函数\" href=\"#类构造函数\"></a></h2>\n<p><code>constructor</code>关键字用于在类定义块内部创建类的构造函数。</p>\n<p>方法名<code>constructor</code>告诉解释器在使用<code>new</code>操作符创建类的新实例时，应该调用这个函数。</p>\n<p>构造函数不是必须的，不定义构造函数相当于将构造函数定义为空函数。</p>\n<h3 id=\"实例化\"><strong>实例化</strong><a title=\"#实例化\" href=\"#实例化\"></a></h3>\n<p>使用<code>new</code>操作符实例化<code>Person</code>的操作等于使用<code>new</code>调用其构造函数。唯一可感知的不同之处是，JavaScript解释器知道使用<code>new</code>和类意味着应该使用<code>constructor</code>函数进行实例化。</p>\n<p><strong>使用<code>new</code>调用类的构造器会执行如下操作：</strong></p>\n<ol>\n<li>在内存中创建一个新对象；</li>\n<li>在这个新对象内部的<code>[[Prototype]]</code>指针被赋值为构造函数的<code>prototype</code>属性；</li>\n<li>构造函数内部的<code>this</code>被赋值为这个新对象（即<code>this</code>指向新对象）；</li>\n<li>执行构造函数内部的代码（给新对象添加属性）；</li>\n<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li>\n</ol>\n<p>默认情况下，类构造函数会在执行后返回<code>this</code>对象。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的<code>this</code>对象，那么这个对象会被销毁。不过，如果返回的不是<code>this</code>对象，而是其他对象，那么这个对象不会通过<code>instanceof</code>操作符检测出跟类有关联，因为这个对象的原指针并没有被修改。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">override</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.foo = <span class=\"string\">&#x27;foo&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(override)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">                bar: <span class=\"string\">&#x27;bar&#x27;</span></span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span> Person);<span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> Person(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p2 <span class=\"keyword\">instanceof</span> Person);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>**类构造函数和构造函数的主要区别是：调用类构造函数必须使用<code>new</code>操作符。**而普通构造函数如果不使用<code>new</code>调用，那么就会以全局的<code>this</code>（通常是<code>window</code>）作为内部对象。调用类构造函数如果忘了使用<code>new</code>会报错。</p>\n<p>类构造函数没有什么特殊之处，实例化后，它会成为普通的实例方法（但作为类构造函数，仍然要使用<code>new</code>调用）。因此，实例化之后可以在实例上引用它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p1.constructor();</span><br><span class=\"line\"><span class=\"comment\">//TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> p1.constructor();<span class=\"comment\">//使用对类构造函数的引用创建一个新实例</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"把类当成特殊函数\">把类当成特殊函数<a title=\"#把类当成特殊函数\" href=\"#把类当成特殊函数\"></a></h3>\n<p>ECMAScript中没有正式的类这个类型。<strong>从各方面来看，ECMAScript类就是一种特殊函数</strong>。声明一个类后，通过<code>typeof</code>操作符检测类标识符，表明它是一个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person);<span class=\"comment\">//class Person&#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> Person);<span class=\"comment\">//function</span></span><br></pre></td></tr></table></figure>\n<p>类标识符有<code>prototype</code>属性，而这个原型也有一个<code>constructor</code>属性指向类自身：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype);<span class=\"comment\">//&#123;constructor: ƒ&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person === Person.prototype.constructor);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>与普通构造函数一样，可以使用<code>instanceof</code>操作符检查构造函数原型是否存在于实例的原型链中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p <span class=\"keyword\">instanceof</span> Person);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>因此，可以使用<code>instanceof</code>确定一个对象是不是类的实例。</p>\n<p>**如前所述，类本身具有普通构造函数一样的行为。**在类的上下文中，类本身在使用<code>new</code>调用时就会被当成构造函数。重点在于，类中定义的<code>constructor</code>方法不会被当成构造函数，在对它使用<code>instanceof</code>操作符时会返回<code>false</code>。但是，如果在创建实例时直接将类构造函数当成普通构造函数使用，那么<code>instanceof</code>操作符的返回值会反转。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1.constructor === Person);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span> Person);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span> Person.constructor);<span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> Person.constructor();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p2.constructor === Person);<span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p2 <span class=\"keyword\">instanceof</span> Person);<span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p2 <span class=\"keyword\">instanceof</span> Person.constructor);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p><strong>类可以像其它对象或函数引用一样把类作为参数传递</strong>。e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类可以像函数一样在任何地方定义，比如说在数组中</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> classList = [</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span></span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">id</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">this</span>.id = _id;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`instance <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.id&#125;</span>`</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createInstance</span>(<span class=\"params\">classDefinition, id</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> classDefinition(id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = createInstance(classList[<span class=\"number\">0</span>], <span class=\"number\">3141</span>);</span><br></pre></td></tr></table></figure>\n<p>**与立即调用函数表达式类似，类也可以立即实例化。**e.g.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">       connsole.log(x);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;(<span class=\"string\">&#x27;bar&#x27;</span>);<span class=\"comment\">//bar</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p);<span class=\"comment\">//Foo&#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"实例、原型和类成员\">实例、原型和类成员<a title=\"#实例、原型和类成员\" href=\"#实例、原型和类成员\"></a></h2>\n<p>类的语法可以非常方便地定义<strong>应该存在于实例上的成员</strong>、<strong>应该存在于原型上的成员</strong>，以及<strong>应该存在于类本身的成员</strong>。</p>\n<h3 id=\"实例成员\">实例成员<a title=\"#实例成员\" href=\"#实例成员\"></a></h3>\n<p>每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;Jack&#x27;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sayName = <span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.nicknames = [<span class=\"string\">&#x27;Jake&#x27;</span>, <span class=\"string\">&#x27;J-dog&#x27;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\">p1.sayName(); <span class=\"comment\">// Jack</span></span><br><span class=\"line\">p2.sayName(); <span class=\"comment\">// Jack</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1.name === p2.name); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1.sayName === p2.sayName); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1.nicknames === p2.nicknames); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">p1.name = p1.nicknames[<span class=\"number\">0</span>];</span><br><span class=\"line\">p2.name = p2.nicknames[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">p1.sayName(); <span class=\"comment\">// Jake</span></span><br><span class=\"line\">p2.sayName(); <span class=\"comment\">// J-Dog</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"原型方法与访问器\">原型方法与访问器<a title=\"#原型方法与访问器\" href=\"#原型方法与访问器\"></a></h3>\n<p>为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加到this的所有内容都会存在于不同的实例上</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.locate = <span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;instance&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">locate</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;prototype&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p.locate();<span class=\"comment\">//instance</span></span><br><span class=\"line\">Person.prototype.locate();<span class=\"comment\">//prototype</span></span><br></pre></td></tr></table></figure>\n<p><strong>可以把方法定义在类构造函数中或类块中，但不能在类块中给原型添加原始值或对象作为成员数据：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">\tname: <span class=\"string\">&#x27;Jake&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Unexpected token</span></span><br></pre></td></tr></table></figure>\n<p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> symbolKey = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;symbolKey&#x27;</span>);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">stringKey</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;invoked stringKey&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [SymbolKey]()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;invoked stringKey&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [<span class=\"string\">&#x27;computed&#x27;</span>+<span class=\"string\">&#x27;Key&#x27;</span>]()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;invoked stringKey&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p.stringKey();  <span class=\"comment\">// invoked stringKey</span></span><br><span class=\"line\">p.[SymbolKey]();<span class=\"comment\">// invoked symbolKey</span></span><br><span class=\"line\">p.computedKey();<span class=\"comment\">// invoked computedKey</span></span><br></pre></td></tr></table></figure>\n<p>类定义也支持获取和设置访问器。语法与行为跟普通对象一样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title\">name</span>(<span class=\"params\">newName</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name_ = newName + <span class=\"string\">&#x27; test&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title\">name</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p.name = <span class=\"string\">&#x27;Andrew&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.name);<span class=\"comment\">//Andrew test</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"静态类方法\">静态类方法<a title=\"#静态类方法\" href=\"#静态类方法\"></a></h3>\n<p>**类上的静态类方法通常用于执行不特定于实例的操作，也不要求存在类的实例。**与原型成员类似，静态成员每个类上只能有一个。</p>\n<blockquote>\n<p>原型成员：e.g. <code>constructor</code>, <code>hasOwnProperty(propertyName)</code>, <code>isPrototypeOf(object)</code>…</p>\n</blockquote>\n<p>静态类成员在类定义中使用<code>static</code>关键字作为前缀。在静态成员中，<code>this</code>引用类自身。其它所有约定跟原型成员一样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加到this的所有内容都会存在于不同的实例上</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.locate = <span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;instance&#x27;</span>, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//定义在类的原型对象上</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">locate</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;prototype&#x27;</span>, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//定义在类本身上，this引用类自身</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">locate</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;class&#x27;</span>, <span class=\"built_in\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p.locate(); <span class=\"comment\">//instance, Person&#123;&#125;</span></span><br><span class=\"line\">Person.prototype.locate();<span class=\"comment\">//prototype, &#123;constructor: ...&#125;</span></span><br><span class=\"line\">Person.locate();<span class=\"comment\">//class, class Person&#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>静态类方法非常适合作为实例工厂：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">age</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.age_ = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">sayAge</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.age_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Person(<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random()*<span class=\"number\">100</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.create());<span class=\"comment\">//Person &#123; age_: 93 &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"非函数原型和类成员\">非函数原型和类成员<a title=\"#非函数原型和类成员\" href=\"#非函数原型和类成员\"></a></h3>\n<p>虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">sayName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"17.009ex\" height=\"2.509ex\" style=\"vertical-align: -0.671ex;\" viewBox=\"0 -791.3 7323.2 1080.4\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">{Person.greeting} </title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-50\" d=\"M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-65\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-72\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-73\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6F\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6E\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-2E\" d=\"M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-67\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-74\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-69\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-50\" x=\"0\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-65\" x=\"751\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-72\" x=\"1218\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-73\" x=\"1669\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-6F\" x=\"2139\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-6E\" x=\"2624\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-2E\" x=\"3225\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-67\" x=\"3670\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-72\" x=\"4150\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-65\" x=\"4602\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-65\" x=\"5068\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-74\" x=\"5535\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-69\" x=\"5896\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-6E\" x=\"6242\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-67\" x=\"6842\" y=\"0\"></use>\n</g>\n</svg>&#123;this.name&#125;`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//在类上定义数据成员</span></span><br><span class=\"line\">Person.greeting = <span class=\"string\">&#x27;My name is&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">//在原型上定义数据成员</span></span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">&#x27;Jake&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p.sayName();<span class=\"comment\">//My name is Jake</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p2.sayName();<span class=\"comment\">//My name is Andrew</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>类定义中之所以没有显式支持添加数据成员，是因为在共享目标（<strong>原型和类</strong>）上添加可变（可修改）数据成员是一种反模式。<strong>一般来说，对象实例应该独自拥有通过<code>this</code>引用的数据。</strong></p>\n</blockquote>\n<h3 id=\"迭代器与生成器方法\">迭代器与生成器方法<a title=\"#迭代器与生成器方法\" href=\"#迭代器与生成器方法\"></a></h3>\n<p><strong>类定义语法支持在原型和类本身上定义生成器方法：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在原型上定义生成器方法</span></span><br><span class=\"line\">    *<span class=\"function\"><span class=\"title\">createNicknameIterator</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;Jack&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;Jake&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;J-Dog&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//在类上定义生成器方法</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> *<span class=\"function\"><span class=\"title\">createJobIterator</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;Butcher&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;Baker&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;CandleStick maker&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> JobIter = Person.createJobIterator();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(JobIter.next().value);<span class=\"comment\">//Butcher</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(JobIter.next().value);<span class=\"comment\">//Baker</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(JobIter.next().value);<span class=\"comment\">//CandleStick maker</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">let</span> NicknameIter = p.createNicknameIterator();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(NicknameIter.next().value);<span class=\"comment\">//Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(NicknameIter.next().value);<span class=\"comment\">//Jake</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(NicknameIter.next().value);<span class=\"comment\">//J-Dog</span></span><br></pre></td></tr></table></figure>\n<p><strong>因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.nicknames = [<span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jake&#x27;</span>, <span class=\"string\">&#x27;J-Dog&#x27;</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *[<span class=\"built_in\">Symbol</span>.iterator]()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> *<span class=\"built_in\">this</span>.nicknames.entries();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> [idx, nickname] <span class=\"keyword\">of</span> p)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(idx, nickname);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0 Jack</span></span><br><span class=\"line\"><span class=\"comment\">// 1 Jake</span></span><br><span class=\"line\"><span class=\"comment\">// 2 J-Dog</span></span><br></pre></td></tr></table></figure>\n<p>也可以只返回迭代器实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.nicknames = [<span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jake&#x27;</span>, <span class=\"string\">&#x27;J-Dog&#x27;</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [<span class=\"built_in\">Symbol</span>.iterator]()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.nicknames.entries();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> [idx, nickname] <span class=\"keyword\">of</span> p)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(idx, nickname);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0 Jack</span></span><br><span class=\"line\"><span class=\"comment\">// 1 Jake</span></span><br><span class=\"line\"><span class=\"comment\">// 2 J-Dog</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"继承\">继承<a title=\"#继承\" href=\"#继承\"></a></h2>\n<p>ES6新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，<strong>但背后依然使用的是原型链。</strong></p>\n<h3 id=\"1.-继承基础\">1. 继承基础<a title=\"#1.-继承基础\" href=\"#1.-继承基础\"></a></h3>\n<p>ES6类支持单继承。使用<code>extends</code>关键字，就可以继承任何拥有<code>[[Construct]]</code>和原型的对象。</p>\n<p>这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//继承类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> Bus();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b <span class=\"keyword\">instanceof</span> Bus);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b <span class=\"keyword\">instanceof</span> Vehicle);<span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//继承构造函数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Engineer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><code>extends</code>关键字也可以在类表达式中使用，因此<code>let Bar = class extends Foo&#123;&#125;</code>是有效的语法。</strong></p>\n<p><strong>派生类都会通过原型链访问到类和原型上定义的方法。<code>this</code>的值会反应调用相应方法的实例或者类。</strong></p>\n<h3 id=\"2.-构造函数、homeobject和super()\">2. 构造函数、HomeObject和Super()<a title=\"#2.-构造函数、homeobject和super()\" href=\"#2.-构造函数、homeobject和super()\"></a></h3>\n<p>派生类的方法可以通过<code>super</code>关键字引用它们的原型。注意：</p>\n<ul>\n<li>\n<p><strong><code>super</code>只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。</strong></p>\n</li>\n<li>\n<p>在**类构造函数中使用<code>super</code>**可以调用父类构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.hasEngine = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//不要在调用super()之前引用this,否则会抛出ReferenceError</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>();<span class=\"comment\">//相当于super.constructor()</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span> <span class=\"keyword\">instanceof</span> Vehicle);<span class=\"comment\">//true</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>);                   <span class=\"comment\">//Bus&#123;hasEngine:true&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Bus();</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>在静态方法中可以通过<code>super</code>调用继承类上定义的静态方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">identify</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;vehicle&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">identify</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.identify();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Bus.identify();<span class=\"comment\">//vehicle</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>ES6给类构造函数和静态方法添加了内部特性<code>[[HomeObject]]</code>，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在JavaScript引擎内部访问。<code>super</code>始终会定义成<code>[[HomeObject]]</code>的原型。</p>\n</blockquote>\n<p><strong>在使用<code>super</code>要注意的几个问题：</strong></p>\n<ol>\n<li>\n<p><code>super</code>只能在派生类构造函数和静态方法中使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>();<span class=\"comment\">// SyntaxError: &#x27;super&#x27; keyword unexpected</span></span><br><span class=\"line\">        <span class=\"comment\">//Vehicle不是派生类</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>不能单独引用<code>super</code>关键字，要么用它调用构造函数，要么用它引用静态方法。</p>\n</li>\n</ol>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">super</span>);<span class=\"comment\">// SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>\n<p>调用<code>super()</code>会调用父类构造函数，并将返回的实例赋值给<code>this</code>。</p>\n</li>\n<li>\n<p><code>super()</code>的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">licensePlate</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.licensePlate = licensePlate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">licensePlate</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(licensePlate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Bus(<span class=\"string\">&#x27;1337H4X&#x27;</span>));<span class=\"comment\">//Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果没有定义类构造函数，在实例化派生类时会调用<code>super()</code>，而且会传入所有传给派生类的参数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">licensePlate</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.licensePlate = licensePlate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Bus(<span class=\"string\">&#x27;1337H4X&#x27;</span>));<span class=\"comment\">//Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>在类构造函数中，不能在调用<code>super()</code>之前引用<code>this</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;Bus&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> Bus();</span><br><span class=\"line\"><span class=\"comment\">// 报错：ReferenceError: Must call super constructor in derived class</span></span><br><span class=\"line\"><span class=\"comment\">// before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>如果在派生类中显式定义了构造函数，则要么必须在其中调用<code>super()</code>，要么必须在其中返回一个对象。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Van</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Car()); <span class=\"comment\">// Car &#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Bus()); <span class=\"comment\">// Bus &#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Van()); <span class=\"comment\">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"3.抽象基类\">3.抽象基类<a title=\"#3.抽象基类\" href=\"#3.抽象基类\"></a></h3>\n<p>有时候可能会需要定义这样一个类，<strong>它可供其他类继承，但本身不会被实例化</strong>。虽然ECMAScript没有专门支持这种类的语法，但通过<code>new.target</code>也很容易实现。<strong><code>new.target</code>保存通过<code>new</code>关键字调用的类或函数。通过在实例化时检测<code>new.target</code>是不是抽象基类，也可以阻止对抽象基类的实例化。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象基类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span>.target);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">new</span>.target === Vehicle)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;Vehicle cannot be directly instantiated.&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> Bus();<span class=\"comment\">//class Bus&#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vehicle();<span class=\"comment\">//class Vehicle&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//Error: Vehicle cannot be directly instantiated.</span></span><br></pre></td></tr></table></figure>\n<p>另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前已经存在了，所以可以通过<code>this</code>关键字来检查相应的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象基类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">new</span>.target === Vehicle)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"built_in\">this</span>.foo)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;Inheriting class must define foo()&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;success&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Van</span> <span class=\"keyword\">extends</span> <span class=\"title\">Vehicle</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> Bus();<span class=\"comment\">//success</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Van();<span class=\"comment\">//Error: Inheriting class must define foo()</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"继承内置类型\">继承内置类型<a title=\"#继承内置类型\" href=\"#继承内置类型\"></a></h3>\n<p>ES6类为继承内置引用类型提供了顺畅的机制，开发者可以<strong>方便地扩展内置类型</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperArray</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">shuffle</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 洗牌算法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">this</span>.length - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> j = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">            [<span class=\"built_in\">this</span>[i], <span class=\"built_in\">this</span>[j]] = [<span class=\"built_in\">this</span>[j], <span class=\"built_in\">this</span>[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> SuperArray(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">a.shuffle();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);<span class=\"comment\">// [3, 1, 4, 5, 2]</span></span><br></pre></td></tr></table></figure>\n<p>有些内置类型的方法会返回新实例。默认情况下，<strong>返回实例的类型与原始实例的类型是一致的</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperArray</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a1 = <span class=\"keyword\">new</span> SuperArray(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> a2 = a1.filter(<span class=\"function\"><span class=\"params\">x</span>=&gt;</span>!(x%<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a2);<span class=\"comment\">// [2,4]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a1 <span class=\"keyword\">instanceof</span> SuperArray);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a2 <span class=\"keyword\">instanceof</span> SuperArray);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>如果想覆盖这个默认行为，则可以覆盖<code>Symbol.species</code>访问器，这个访问器决定在创建返回实例时使用的类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperArray</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> get [<span class=\"built_in\">Symbol</span>.species]()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a1 = <span class=\"keyword\">new</span> SuperArray(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> a2 = a1.filter(<span class=\"function\"><span class=\"params\">x</span>=&gt;</span>!(x%<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a1 <span class=\"keyword\">instanceof</span> SuperArray);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a2 <span class=\"keyword\">instanceof</span> SuperArray);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类混入\">类混入<a title=\"#类混入\" href=\"#类混入\"></a></h3>\n<p>把不同类的行为集中到一个类是一种常见的JavaScript模式。虽然ES6没有显式支持多类继承，但通过现有特性可以轻松地模拟这种行为。</p>\n<hr>\n<p>注意：<code>Object.assign()</code>方法是为了<strong>混入对象行为</strong>而设计的。只有在需要<strong>混入类的行为</strong>时才有必要自己实现混入表达式。<strong>如果只是需要混入多个对象的属性，那么使用<code>Object.assign()</code>就可以了。</strong></p>\n<hr>\n<p><strong>其余见书P263-265</strong></p>\n","prev":{"title":"链表（Linked List）","link":"2021/03/25/数据结构/链表（Linked List）"},"next":{"title":"每日一题：LC456 132模式","link":"2021/03/24/刷题日记/每日一题：LC456 132模式"},"plink":"http://example.com/2021/03/25/JavaScript/8-4-类/","toc":[{"id":"类","title":"类","index":"1","children":[{"id":"类声明","title":"类声明","index":"1.1","children":[{"id":"类的构成","title":"类的构成","index":"1.1.1"}]},{"id":"类构造函数","title":"类构造函数","index":"1.2","children":[{"id":"实例化","title":"实例化","index":"1.2.1"},{"id":"把类当成特殊函数","title":"把类当成特殊函数","index":"1.2.2"}]},{"id":"实例、原型和类成员","title":"实例、原型和类成员","index":"1.3","children":[{"id":"实例成员","title":"实例成员","index":"1.3.1"},{"id":"原型方法与访问器","title":"原型方法与访问器","index":"1.3.2"},{"id":"静态类方法","title":"静态类方法","index":"1.3.3"},{"id":"非函数原型和类成员","title":"非函数原型和类成员","index":"1.3.4"},{"id":"迭代器与生成器方法","title":"迭代器与生成器方法","index":"1.3.5"}]},{"id":"继承","title":"继承","index":"1.4","children":[{"id":"1.-继承基础","title":"1. 继承基础","index":"1.4.1"},{"id":"2.-构造函数、homeobject和super()","title":"2. 构造函数、HomeObject和Super()","index":"1.4.2"},{"id":"3.抽象基类","title":"3.抽象基类","index":"1.4.3"},{"id":"继承内置类型","title":"继承内置类型","index":"1.4.4"},{"id":"类混入","title":"类混入","index":"1.4.5"}]}]}]}