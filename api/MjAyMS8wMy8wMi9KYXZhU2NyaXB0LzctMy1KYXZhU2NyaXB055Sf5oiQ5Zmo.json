{"title":"7.3 JavaScript生成器","date":"2021-03-01T16:00:00.000Z","date_formatted":{"ll":"Mar 2, 2021","L":"03/02/2021","MM-DD":"03-02"},"link":"2021/03/02/JavaScript/7-3-JavaScript生成器","tags":["JavaScript"],"categories":["JS Technique"],"updated":"2021-03-02T09:17:52.287Z","content":"<h1 id=\"javascript生成器\">JavaScript生成器<a title=\"#javascript生成器\" href=\"#javascript生成器\"></a></h1>\n<p>ECMA6引入的一种极为灵活的结构，拥有在一个函数块内<strong>暂停和恢复代码执行的能力</strong>。</p>\n<p>使用生成器可以<strong>自定义迭代器和实现协程</strong>。</p>\n<h2 id=\"生成器基础\">生成器基础<a title=\"#生成器基础\" href=\"#生成器基础\"></a></h2>\n<p>生成器的形式是一个函数，函数名称前加一个 ‘ * ’ 表示它是一个生成器。只要是可以定义函数的地方就可以定义生成器。<strong>表示生成器函数的型号不受两侧空格影响</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//生成器函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">generatorFn</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//生成器函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> generatorFn = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//作为对象字面量方法的生成器函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">    * <span class=\"function\"><span class=\"title\">generatorFn</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//作为类实例方法的生成器函数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span>&#123;</span><br><span class=\"line\">    * <span class=\"function\"><span class=\"title\">generator</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//作为类静态方法的生成器函数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> * <span class=\"function\"><span class=\"title\">generatorFn</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>生成器一开始处于<strong>暂停执行</strong>（suspended）状态。它实现了迭代器接口，具有<code>next( )</code>方法。调用这个方法会开始或恢复执行。</p>\n<p><code>next()</code>方法的返回值类似于迭代器，有一个<code>done</code>属性和一个<code>value</code> 属性。函数体为空的生成器函数中间不会停留，调用一次<code>next()</code>就会让生成器到达<code>done:true</code>状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> * <span class=\"title\">generatorFn</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = generatorFn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next);<span class=\"comment\">//[Function: next]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next());<span class=\"comment\">//&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<p>value属性是生成器函数的返回值，默认值是<code>undefined</code>，可以通过生成器函数的返回值指定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> * <span class=\"title\">generatorFn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&#x27;Foo&#x27;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = generatorFn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next());<span class=\"comment\">//&#123; value: &#x27;Foo&#x27;, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>生成器函数只会在初次调用<code>next()</code>方法后开始执行</strong>。</p>\n<h2 id=\"通过yield中断执行\">通过yield中断执行<a title=\"#通过yield中断执行\" href=\"#通过yield中断执行\"></a></h2>\n<p>在遇到<code>yield</code>前会正常执行，遇到这个关键字，执行会停止，函数作用域的状态会保留。停止执行的生成器函数只能通过在生成器对象上调用<code>next()</code>方法来恢复执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> * <span class=\"title\">generatorFn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">yield</span> <span class=\"string\">&#x27;foo&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;bar&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;baz&#x27;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = generatorFn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next());<span class=\"comment\">//&#123; value: &#x27;foo&#x27;, done: false &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next());<span class=\"comment\">//&#123; value: &#x27;bar&#x27;, done: false &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next());<span class=\"comment\">//&#123; value: &#x27;baz&#x27;, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><strong>生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器上调用<code>next()</code>不会影响其它生成器。</strong></p>\n</li>\n<li>\n<p>yield关键字<strong>只能在生成器函数内部使用</strong>，用在其它地方会抛出错误。类似函数的return关键字，yield关键字必须直接位于生成器函数定义中。</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><strong>用法</strong>：</li>\n</ul>\n<ol>\n<li>\n<p><strong>生成器对象作为可迭代对象</strong></p>\n<p>在生成器对象上显式调用<code>next()</code>方法用处并不大。把生成器对象当作可迭代对象使用起来会更方便。</p>\n<p>这样使用生成器会特别有用。e.g. 比如我们需要定义一个可迭代对象，它会产生一个迭代器，这个迭代器会执行指定的次数。使用生成器，可以通过一个简单的循环实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> * <span class=\"title\">nTimes</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> _ <span class=\"keyword\">of</span> nTimes(<span class=\"number\">3</span>))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;foo&#x27;</span>);</span><br><span class=\"line\">&#125;<span class=\"comment\">//foo foo foo</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>使用yield实现输入和输出</strong></p>\n<p>除了可以作为函数的中间返回语句使用，yield关键字还可以作为<strong>函数的中间参数使用</strong>。上一次让生成器函数暂停的yield关键字会接收到传给<code>next()</code>方法的第一个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> * <span class=\"title\">generatorFn</span>(<span class=\"params\">initial</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(initial);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">yield</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">yield</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = generatorFn(<span class=\"string\">&#x27;foo&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">//第一次调用next()转入的值不会被使用，因为这一次调用是为了开始执行生成器函数</span></span><br><span class=\"line\">g.next(<span class=\"string\">&#x27;bar&#x27;</span>);<span class=\"comment\">//foo</span></span><br><span class=\"line\">g.next(<span class=\"string\">&#x27;baz&#x27;</span>);<span class=\"comment\">//baz</span></span><br><span class=\"line\">g.next(<span class=\"string\">&#x27;qux&#x27;</span>);<span class=\"comment\">//qux</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>yield关键字可以同时作为输入和输出（难理解）</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> * <span class=\"title\">generatorFn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;foo&#x27;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = generatorFn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next());<span class=\"comment\">//&#123; value: &#x27;foo&#x27;, done: false &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next(<span class=\"string\">&#x27;bar&#x27;</span>));<span class=\"comment\">//&#123; value: &#x27;bar&#x27;, done: true &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next(<span class=\"string\">&#x27;qux&#x27;</span>));<span class=\"comment\">//&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<p>因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到<code>yield</code>关键字时暂停执行并<br>\n计算出要产生的值：<code>foo</code>。下一次调用<code>next()</code>传入了<code>bar</code>，作为交给同一个<code>yield</code>的值。然后这<br>\n个值被确定为本次生成器函数要返回的值。</p>\n</li>\n<li>\n<p><strong>产生可迭代对象</strong></p>\n<p>使用星号增强yield的行为，让它能够迭代一个可迭代对象，从而一次产出一个值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//等价的generatorFn()</span></span><br><span class=\"line\"><span class=\"comment\">//function* generatorFn()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\tfor(const x of [1,2,3])&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tyield x;</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">generatorFn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">yield</span>* [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = generatorFn();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> generatorFn())&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x);<span class=\"comment\">// 1 2 3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>yield*</code>实际上只是一个将可迭代对象序列化为一连串可以单独产出的值，所以这跟把yield放到一个循环里没有什么不同。</p>\n<p><strong>P199（不是很理解）</strong>：</p>\n<ul>\n<li><code>yield*</code>的值是关联迭代器返回<code>done:true</code>时的<code>value</code>属性。对于普通迭代器来说，这个值是undefined</li>\n<li>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值。</li>\n</ul>\n</li>\n<li>\n<p><strong>使用yield*实现递归算法</strong></p>\n<p>yield*最有用的地方是实现递归操作，此时生成器可以产生自身：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">nTimes</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">yield</span>* nTimes(n-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">yield</span> n-<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> nTimes(<span class=\"number\">3</span>))&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数。</p>\n<p>使用递归生成器结构和yield*可以优雅地表达递归算法。</p>\n<p>图数据结构非常适合递归遍历，而递归生成器恰好非常合用。因此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通。使用yield可以做到一个非常简洁的深度优先遍历：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">isConnected</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> visitedNodes = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">traverse</span>(<span class=\"params\">nodes</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> node <span class=\"keyword\">of</span> nodes)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!visitedNodes.has(node))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> node;</span><br><span class=\"line\">              \t<span class=\"keyword\">yield</span>* traverse(node.neighbors);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//取得集合中的第一个结点</span></span><br><span class=\"line\"> \t<span class=\"keyword\">const</span> firstNode = <span class=\"built_in\">this</span>.nodes[<span class=\"built_in\">Symbol</span>.iterator]().next().value;</span><br><span class=\"line\">    <span class=\"comment\">//使用递归生成器迭代每个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> node <span class=\"keyword\">of</span> traverse([firstNode]))&#123;</span><br><span class=\"line\">\t\tvisitedNodes.add(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> visitedNodes.size === <span class=\"built_in\">this</span>.node.size</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"生成器作为默认迭代器\">生成器作为默认迭代器<a title=\"#生成器作为默认迭代器\" href=\"#生成器作为默认迭代器\"></a></h2>\n<p>生成器对象使用了<code>Iterable</code>接口，生成器函数和默认迭代器被调用后都产生迭代器，<strong>所以生成器格外适合作为默认迭代器</strong>。e.g. 这个类的默认迭代器可以用一行代码产出类的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.values = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*[<span class=\"built_in\">Symbol</span>.iterator]()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">yield</span>* <span class=\"built_in\">this</span>.values;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> f)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<p><code>for-of</code>调用了默认迭代器（它恰好又是一个生成器函数）并产生了一个生成器对象。这个生成器对象时可迭代的，因此完全可以在迭代中使用。</p>\n<h2 id=\"提前终止迭代器\">提前终止迭代器<a title=\"#提前终止迭代器\" href=\"#提前终止迭代器\"></a></h2>\n<p>与迭代器类似，生成器也支持”可关闭“概念。一个实现Iterator接口的对象一定有<code>next()</code>方法，还有一个可选的<code>return()</code>方法用于提前终止迭代器。生成器除了有这两个方法，还有第三个方法：<code>throw()</code></p>\n<ul>\n<li>\n<p><code>return()</code>和<code>throw()</code>都可以用于强制生成器进入关闭状态</p>\n<h3 id=\"return()\">return()<a title=\"#return()\" href=\"#return()\"></a></h3>\n<p><code>return()</code>方法强制生成器进入关闭状态。提供给<code>return()</code>方法的值，就是终止迭代器对象的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">generatorFn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">yield</span> x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = generatorFn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g);<span class=\"comment\">//generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.return(<span class=\"number\">4</span>));<span class=\"comment\">//&#123; value: 4, done: true &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g);<span class=\"comment\">//generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>所有生成器对象都有<code>return()</code>方法，一旦进入关闭状态就无法恢复，后续调用<code>next()</code>会显示<code>done:true</code>状态</p>\n<p><code>for-of</code>循环等内置语言结构会忽略状态为<code>done:true</code>的<code>IteratorObject</code>内部返回的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">generatorFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">yield</span> x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = generatorFn();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> g) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tg.return(<span class=\"number\">4</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"throw()\">throw()<a title=\"#throw()\" href=\"#throw()\"></a></h3>\n<p><code>throw()</code>会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">generatorFn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">yield</span> x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = generatorFn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g);<span class=\"comment\">//generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\tg.throw(<span class=\"string\">&#x27;foo&#x27;</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(e);<span class=\"comment\">//foo</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g);<span class=\"comment\">//generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>但是假如生成器函数内部处理了这个错误，则生成器不会被关闭，且可以恢复执行。错误处理会跳过相应的yield，因此下面的例子中会跳过一个值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">generatorFn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">yield</span> x;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">catch</span>(e)&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = generatorFn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next());<span class=\"comment\">//&#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.throw(<span class=\"string\">&#x27;foo&#x27;</span>)<span class=\"comment\">//yield抛出错误，因此生成器不会再产出值2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next());<span class=\"comment\">//&#123; value: 3, done: false &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next());<span class=\"comment\">//&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"小结\">小结<a title=\"#小结\" href=\"#小结\"></a></h1>\n<p>生成器是一种特殊的函数，调用之后会返回一个生成器对象。<strong>生成器对象实现了<code>Iterable</code>接口，因此可用在任何消费可迭代对象的地方</strong>。生成器的独特之处在于支持<code>yield</code>关键字，这个关键字能够暂停执行生成器函数。使用<code>yield</code>关键字还可以通过<code>next()</code>方法接收输入和产生输出。在加上星号之后，<code>yield</code>关键字可以将跟在它后面的可迭代对象序列化为一连串值。</p>\n","prev":{"title":"8.1 理解对象","link":"2021/03/02/JavaScript/8-1-理解对象"},"next":{"title":"7.2 JavaScript迭代器","link":"2021/03/01/JavaScript/7-2-JavaScript迭代器"},"plink":"http://example.com/2021/03/02/JavaScript/7-3-JavaScript生成器/","toc":[{"id":"javascript生成器","title":"JavaScript生成器","index":"1","children":[{"id":"生成器基础","title":"生成器基础","index":"1.1"},{"id":"通过yield中断执行","title":"通过yield中断执行","index":"1.2"},{"id":"生成器作为默认迭代器","title":"生成器作为默认迭代器","index":"1.3"},{"id":"提前终止迭代器","title":"提前终止迭代器","index":"1.4","children":[{"id":"return()","title":"return()","index":"1.4.1"},{"id":"throw()","title":"throw()","index":"1.4.2"}]}]},{"id":"小结","title":"小结","index":"2"}]}