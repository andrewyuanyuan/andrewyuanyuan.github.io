{"title":"每日一题：LC430 扁平化多级双向链表（待理解）","date":"2021-03-29T16:00:00.000Z","date_formatted":{"ll":"Mar 30, 2021","L":"03/30/2021","MM-DD":"03-30"},"link":"2021/03/30/刷题日记/每日一题：LC430 扁平化多级双向链表","tags":["LeetCode"],"categories":["LeetCode"],"updated":"2021-03-30T08:28:55.917Z","content":"<h1 id=\"每日一题：lc430-扁平化多级双向链表\">每日一题：LC430 扁平化多级双向链表<a title=\"#每日一题：lc430-扁平化多级双向链表\" href=\"#每日一题：lc430-扁平化多级双向链表\"></a></h1>\n<p><a href=\"https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/\" target=\"_blank\">430. 扁平化多级双向链表</a><strong>Medium</strong></p>\n<p>本文内容来源：</p>\n<ol>\n<li><a href=\"https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/solution/bian-ping-hua-duo-ji-shuang-xiang-lian-biao-by-lee/\" target=\"_blank\">LeetCode</a>官方解答</li>\n<li>作者ninjutsu于<a href=\"https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/solution/430-dfsshi-xian-jian-dan-yi-li-jie-dai-z-n6dj/\" target=\"_blank\">Leetcode的回答</a></li>\n</ol>\n<hr>\n<h2 id=\"补充：由dfs（先序遍历）的容易理解的解法\">补充：由DFS（先序遍历）的容易理解的解法<a title=\"#补充：由dfs（先序遍历）的容易理解的解法\" href=\"#补充：由dfs（先序遍历）的容易理解的解法\"></a></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preOrder</span><span class=\"params\">(TreeNode node)</span>&#125;</span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"title\">if</span><span class=\"params\">(node == <span class=\"keyword\">null</span>)</span>\treturn</span>;</span><br><span class=\"line\">\tlist.add(node);</span><br><span class=\"line\">\tpreOrder(node.left);</span><br><span class=\"line\">\tpreOrder(node.right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此出发：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node ans;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node cur;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">flatten</span><span class=\"params\">(Node head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(head);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//看成二叉树的前序遍历</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(Node node)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//相当于前序遍历的主体，把遍历到的当前节点放入新的链表里</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            ans = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">            ans.val = node.val;</span><br><span class=\"line\">            cur = ans;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            Node newNode = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">            newNode.val = node.val;</span><br><span class=\"line\">            cur.next = newNode;</span><br><span class=\"line\">            newNode.prev = cur;</span><br><span class=\"line\">            cur = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//优先迭代子节点，再迭代下一个节点</span></span><br><span class=\"line\">        dfs(node.child);</span><br><span class=\"line\">        dfs(node.next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"递归的深度优先搜索\">递归的深度优先搜索<a title=\"#递归的深度优先搜索\" href=\"#递归的深度优先搜索\"></a></h2>\n<p>将链表顺时针旋转90°，就会看到一颗二叉树，则扁平化的操作也就是对二叉树进行先序遍历（根左右）。</p>\n<p>将<code>child</code>指针当作二叉树中指向左子树的<code>left</code>指针。同样，<code>next</code>指针可以当作二叉树中的<code>right</code>指针。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">flatten</span><span class=\"params\">(Node head)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head==<span class=\"keyword\">null</span>)  <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        Node pseudoHead = <span class=\"keyword\">new</span> Node(<span class=\"number\">0</span>, <span class=\"keyword\">null</span>, head, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        flattenDFS(pseudoHead, head);</span><br><span class=\"line\"></span><br><span class=\"line\">        pseudoHead.next.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pseudoHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//flattenDFS接收两个指针作为函数参数并返回扁平化列表中的尾部指针</span></span><br><span class=\"line\">    <span class=\"comment\">//curr指针指向我们要扁平化的子列表</span></span><br><span class=\"line\">    <span class=\"comment\">//prev指针指向curr指向元素的前一个元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">flattenDFS</span><span class=\"params\">(Node prev, Node curr)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(curr == <span class=\"keyword\">null</span>)    <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">        <span class=\"comment\">//首先在prev和curr节点之间建立双向连接</span></span><br><span class=\"line\">        curr.prev = prev;</span><br><span class=\"line\">        prev.next = curr;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node tempNext = curr.next;</span><br><span class=\"line\">        <span class=\"comment\">//在函数中调用flatten_dfs(curr, curr.child)对左子树（curr.child即子列表）进行操作</span></span><br><span class=\"line\">        <span class=\"comment\">//它将返回扁平化子列表的尾部元素tail</span></span><br><span class=\"line\">        Node tail = flattenDFS(curr, curr.child);</span><br><span class=\"line\">        curr.child = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//再调用flatten_dfs(tail, curr.next)对右子树进行操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> flattenDFS(tail, tempNext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了得到正确的结果，我们还需要注意两个重要的细节：</p>\n<ol>\n<li>在调用<code>flatten_dfs(curr, curr.child)</code>之前我们应该复制<code>curr.next</code>指针，因为<code>curr.next</code>可能在函数中改变。</li>\n<li>在扁平化<code>curr.child</code>指针所指向的列表以后，我们应该删除<code>child</code>指针，因为我们最终不再需要该指针。</li>\n</ol>\n","prev":{"title":"note","link":"2021/03/30/JavaScript/Note"},"next":{"title":"HTML5","link":"2021/03/29/HTML&CSS/HTML5初步"},"plink":"http://example.com/2021/03/30/刷题日记/每日一题：LC430 扁平化多级双向链表/","toc":[{"id":"每日一题：lc430-扁平化多级双向链表","title":"每日一题：LC430 扁平化多级双向链表","index":"1","children":[{"id":"补充：由dfs（先序遍历）的容易理解的解法","title":"补充：由DFS（先序遍历）的容易理解的解法","index":"1.1"},{"id":"递归的深度优先搜索","title":"递归的深度优先搜索","index":"1.2"}]}]}